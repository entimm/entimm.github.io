<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Entimm&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://entimm.com/"/>
  <updated>2016-09-18T23:44:51.000Z</updated>
  <id>https://entimm.com/</id>
  
  <author>
    <name>entimm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>php tips</title>
    <link href="https://entimm.com/2016/09/19/php-tip/"/>
    <id>https://entimm.com/2016/09/19/php-tip/</id>
    <published>2016-09-18T23:44:51.000Z</published>
    <updated>2016-09-18T23:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>explode 分割字符可以不是单字符</p>
</li>
<li><p>强制类型转换的值不论是否有定义，转换后都会有值</p>
</li>
<li><p>E_ALL ^ E_NOTICE 和 E_ALL &amp; ~E_NOTICE 是等效的</p>
</li>
<li><p>无论是函数调用还是文件包含，像 <strong>FILE</strong> 这种变量，他写在哪个文件，那么他的值就在哪个文件，而不受调用者影响</p>
</li>
<li><p>静态变量是在编译时解析的，不能跟表达式，比如：static $int = sqrt(121)</p>
</li>
<li><p>子类重载父类的属性和方法时，可见性不能比父类小</p>
</li>
<li><p>自 PHP 5.4 起可用 callable 类型指定回调类型 callback</p>
<ol>
<li><p>一个 PHP 的函数以 string 类型传递其名称。可以使用任何内置或用户自定义函数，但除了语言结构例如：array()，echo，empty()，eval()，exit()，isset()，list()，print 或 unset()</p>
</li>
<li><p>一个已实例化的对象的方法被作为数组传递，下标 0 包含该对象，下标 1 包含方法名</p>
</li>
<li><p>静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。自 PHP 5.2.3 起，也可以传递 ‘ClassName::methodName’</p>
</li>
<li><p>也可传递 closure 给回调参数</p>
</li>
</ol>
</li>
<li><p>对浮点数，数字字符串，纯字母都能进行自增/减运算，对其他类型的值进行自增/减运算不会产生什么效果</p>
</li>
<li><p>call_user_func_array 如果回调函数默认设置需要接受的参数是引用传递的时候，按值传递，结果将会输出一个警告, 这时数组参数中的参数需要按引用传递</p>
</li>
<li><p>call_user_func 如果回调函数默认设置需要接受的参数是引用传递的时候,无论怎样传参都无法满足</p>
</li>
<li><p>常量<strong>NAMESPACE</strong>的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串</p>
</li>
<li>关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符</li>
<li><p>命名空间不会因为被包含而影响其在包含文件中的使用方式</p>
</li>
<li><p>mysqli::real_escape_string 相比 addslashes 会针对真实数据库环境的字符集做出更好的处理，但是必须在建立数据库链接的基础上</p>
</li>
<li><p>字符串类型变量可以直接当做一个数组，通过数字下面来访问字符串中的字符或者是通过 str_split 函数把字符串分割成单字符数组</p>
</li>
</ul>
<h3 id="那些有趣的代码片段"><a href="#那些有趣的代码片段" class="headerlink" title="那些有趣的代码片段"></a>那些有趣的代码片段</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multi</span> <span class="params">($a, $b)</span> </span>&#123;</div><div class="line">    $b = is_array($b) ? $b : array_slice(func_get_args(), <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incr</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> $count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    $count++;</div><div class="line">    <span class="keyword">echo</span> $count;</div><div class="line">    <span class="keyword">if</span> ($count &lt; <span class="number">10</span>) &#123;</div><div class="line">        incr();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">echo</span> $count;</div><div class="line">    $count--;</div><div class="line">&#125;</div><div class="line">incr();</div><div class="line"><span class="comment">// 结果输出：1234567891010987654321</span></div></pre></td></tr></table></figure>
<p>不使用临时变量，交换2数的数值<br>下面三种方法不能对自身进行交换<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不仅对数字有效，对字符串也是有效的</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap1</span><span class="params">(&amp;$x, &amp;$y)</span></span></div><div class="line">&#123;</div><div class="line">    $x = $x ^ $y;</div><div class="line">    $y = $x ^ $y;</div><div class="line">    $x = $x ^ $y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当心越界</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap2</span><span class="params">(&amp;$x, &amp;$y)</span></span></div><div class="line">&#123;</div><div class="line">    $x = $x + $y;</div><div class="line">    $y = $x - $y;</div><div class="line">    $x = $x - $y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当心越界、第二个数不能为0</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap3</span><span class="params">(&amp;$x, &amp;$y)</span></span></div><div class="line">&#123;</div><div class="line">    $x = $x * $y;</div><div class="line">    $y = $x / $y;</div><div class="line">    $x = $x / $y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>命名空间<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">Myns</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">new</span> <span class="keyword">namespace</span>\<span class="title">Test</span>;</div><div class="line"></div><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">new</span> Test;</div><div class="line"></div><div class="line"><span class="comment">// ok</span></div><div class="line">$a =  <span class="keyword">__NAMESPACE__</span> . <span class="string">'\Test'</span>;</div><div class="line"><span class="keyword">new</span> $a;</div><div class="line"></div><div class="line"><span class="comment">// ok</span></div><div class="line">$a =  <span class="string">'Myns\Test'</span>;</div><div class="line"><span class="keyword">new</span> $a;</div><div class="line"></div><div class="line"><span class="comment">// failed,  Class 'Myns\Myns\Test' not found</span></div><div class="line"><span class="keyword">new</span> Myns\Test;</div></pre></td></tr></table></figure></p>
<p>这样的自增运算<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$i1 = <span class="number">0</span>;</div><div class="line">$i2 = <span class="number">0</span>;</div><div class="line">$a= ++$i1 + ++$i1 + ++$i1;</div><div class="line">$b= $i2++ + $i2++ + $i2++;</div><div class="line"><span class="keyword">echo</span> $a;</div><div class="line"><span class="keyword">echo</span> PHP_EOL;</div><div class="line"><span class="keyword">echo</span> $b;</div><div class="line"><span class="comment">// result:</span></div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;explode 分割字符可以不是单字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;强制类型转换的值不论是否有定义，转换后都会有值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E_ALL ^ E_NOTICE 和 E_ALL &amp;amp; ~E_NOTICE 是等效的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无论是函数调用还是文件包含，像 &lt;strong&gt;FILE&lt;/strong&gt; 这种变量，他写在哪个文件，那么他的值就在哪个文件，而不受调用者影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态变量是在编译时解析的，不能跟表达式，比如：static $int = sqrt(121)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类重载父类的属性和方法时，可见性不能比父类小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自 PHP 5.4 起可用 callable 类型指定回调类型 callback&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个 PHP 的函数以 string 类型传递其名称。可以使用任何内置或用户自定义函数，但除了语言结构例如：array()，echo，empty()，eval()，exit()，isset()，list()，print 或 unset()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个已实例化的对象的方法被作为数组传递，下标 0 包含该对象，下标 1 包含方法名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。自 PHP 5.2.3 起，也可以传递 ‘ClassName::methodName’&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可传递 closure 给回调参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对浮点数，数字字符串，纯字母都能进行自增/减运算，对其他类型的值进行自增/减运算不会产生什么效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;call_user_func_array 如果回调函数默认设置需要接受的参数是引用传递的时候，按值传递，结果将会输出一个警告, 这时数组参数中的参数需要按引用传递&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;call_user_func 如果回调函数默认设置需要接受的参数是引用传递的时候,无论怎样传参都无法满足&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常量&lt;strong&gt;NAMESPACE&lt;/strong&gt;的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命名空间不会因为被包含而影响其在包含文件中的使用方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mysqli::real_escape_string 相比 addslashes 会针对真实数据库环境的字符集做出更好的处理，但是必须在建立数据库链接的基础上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串类型变量可以直接当做一个数组，通过数字下面来访问字符串中的字符或者是通过 str_split 函数把字符串分割成单字符数组&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;那些有趣的代码片段&quot;&gt;&lt;a href=&quot;#那些有趣的代码片段&quot; class=&quot;headerlink&quot; title=&quot;那些有趣的代码片段&quot;&gt;&lt;/a&gt;那些有趣的代码片段&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;multi&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($a, $b)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $b = is_array($b) ? $b : array_slice(func_get_args(), &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; $count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $count++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ($count &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        incr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $count--;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;incr();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 结果输出：1234567891010987654321&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tmux使用</title>
    <link href="https://entimm.com/2016/09/19/tmux/"/>
    <id>https://entimm.com/2016/09/19/tmux/</id>
    <published>2016-09-18T23:41:25.000Z</published>
    <updated>2016-09-18T23:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>&lt;prefix&gt;$</code>可以重命名当前Session<br><code>&lt;prefix&gt;c</code>可以创建新的窗口（Window）<br><code>&lt;prefix&gt;%</code>水平分割窗口（形成两个Pane）<br><code>&lt;prefix&gt;&quot;</code>垂直分割窗口。退出当前Session的快捷键是<code>&lt;prefix&gt;d</code></p>
<p>在Bash中可以查看当前的tmux服务中有哪些Session：<code>tmux ls</code><br>根据Session的名字可以再回去：<code>tmux a -t myname  (or at, or attach)</code></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>默认的<code>&lt;prefix&gt;</code>是<code>Ctrl+b</code>，如果觉得不好按可以调整为<code>Ctrl+a</code>，只需要在配置文件~/.tmux.conf中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unbind ^b</div><div class="line">set -g prefix &apos;C-a&apos;</div></pre></td></tr></table></figure></p>
<p>为了能让Tmux动态载入配置而不是重启，我们设一个快捷键<prefix>r来重新载入配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind r source-file ~/.tmux.conf \; display-message &quot;Config reloaded&quot;</div></pre></td></tr></table></figure></prefix></p>
<p>当前tmux的设置，可通过tmux show -g</p>
<h3 id="窗格切换"><a href="#窗格切换" class="headerlink" title="窗格切换"></a>窗格切换</h3><p>可以把hjkl设置为切换窗格的快捷键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bind h select-pane -L</div><div class="line">bind j select-pane -D</div><div class="line">bind k select-pane -U</div><div class="line">bind l select-pane -R</div></pre></td></tr></table></figure></p>
<p>再给调整窗格大小设置快捷键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bind L resize-pane -L 10  # 向左扩展</div><div class="line">bind R resize-pane -R 10  # 向右扩展</div><div class="line">bind K resize-pane -U 5   # 向上扩展</div><div class="line">bind J resize-pane -D 5   # 向下扩展</div></pre></td></tr></table></figure></p>
<p>我们发现当打开新窗格时Shell仍然在Home目录，可以设置为当前目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bind &apos;&quot;&apos; split-window -c &apos;#&#123;pane_current_path&#125;&apos;</div><div class="line">bind &apos;%&apos; split-window -h -c &apos;#&#123;pane_current_path&#125;&apos;</div></pre></td></tr></table></figure></p>
<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>在Tmux中通过[进入拷贝模式，按下<code>&lt;space&gt;</code>开始拷贝。然后用Vim/Emacs快捷键选择文本，按下<enter>拷贝所选内容。然后通过]进行粘贴</enter></p>
<p>上述所有快捷键中，只有[和]需要先按下<code>&lt;prefix&gt;</code>。<br>我们可以让上述拷贝快捷键符合Vi风格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bind Escape copy-mode</div><div class="line">bind -t vi-copy v begin-selection</div><div class="line">bind -t vi-copy y copy-selection</div><div class="line">unbind p</div><div class="line">bind p pasteb</div><div class="line">setw -g mode-keys vi      # Vi风格选择文本</div></pre></td></tr></table></figure></p>
<p>这样，按下<code>&lt;Escape&gt;</code>进入拷贝模式，v进行选择，y拷贝所选内容，p进行粘贴。</p>
<h3 id="鼠标切换窗格"><a href="#鼠标切换窗格" class="headerlink" title="鼠标切换窗格"></a>鼠标切换窗格</h3><p>Tmux和Vim风格非常像，也可以设置鼠标模式。下面的设置开启了所有鼠标功能： 通过点击选择窗格，通过拖动更改窗格大小，通过鼠标选择窗口，还可以通过鼠标选择复制区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setw -g mode-mouse on</div><div class="line">set -g mouse-select-pane on</div><div class="line">set -g mouse-resize-pane on</div><div class="line">set -g mouse-select-window on</div></pre></td></tr></table></figure></p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>Sessions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:new&lt;CR&gt; new session</div><div class="line">s  list sessions</div><div class="line">$  name session</div></pre></td></tr></table></figure></p>
<p>:new -s <session-name> 可以指定新Session的名字。</session-name></p>
<p>Windows (tabs)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">c  create window</div><div class="line">w  list windows</div><div class="line">n  next window</div><div class="line">p  previous window</div><div class="line">f  find window</div><div class="line">,  name window</div><div class="line">&amp;  kill window</div></pre></td></tr></table></figure></p>
<p>Panes (splits)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">%  vertical split</div><div class="line">&quot;  horizontal split</div><div class="line"></div><div class="line">o  swap panes</div><div class="line">q  show pane numbers</div><div class="line">x  kill pane</div><div class="line">+  break pane into window (e.g. to select text by mouse to copy)</div><div class="line">-  restore pane from window</div><div class="line">⍽  space - toggle between layouts</div><div class="line">&lt;prefix&gt; q (Show pane numbers, when the numbers show up type the key to goto that pane)</div><div class="line">&lt;prefix&gt; &#123; (Move the current pane left)</div><div class="line">&lt;prefix&gt; &#125; (Move the current pane right)</div><div class="line">&lt;prefix&gt; z toggle pane zoom</div></pre></td></tr></table></figure></p>
<p>Misc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d  detach</div><div class="line">t  big clock</div><div class="line">?  list shortcuts</div><div class="line">:  prompt</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;&amp;lt;prefix&amp;gt;$&lt;/code&gt;可以重命名当前Session&lt;br&gt;&lt;code&gt;&amp;lt;prefix&amp;gt;c&lt;/code&gt;可以创建新的窗口（Window）&lt;br&gt;&lt;code&gt;&amp;lt;prefix&amp;gt;%&lt;/code&gt;水平分割窗口（形成两个Pane）&lt;br&gt;&lt;code&gt;&amp;lt;prefix&amp;gt;&amp;quot;&lt;/code&gt;垂直分割窗口。退出当前Session的快捷键是&lt;code&gt;&amp;lt;prefix&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Bash中可以查看当前的tmux服务中有哪些Session：&lt;code&gt;tmux ls&lt;/code&gt;&lt;br&gt;根据Session的名字可以再回去：&lt;code&gt;tmux a -t myname  (or at, or attach)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h3&gt;&lt;p&gt;默认的&lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;是&lt;code&gt;Ctrl+b&lt;/code&gt;，如果觉得不好按可以调整为&lt;code&gt;Ctrl+a&lt;/code&gt;，只需要在配置文件~/.tmux.conf中加入：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;unbind ^b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;set -g prefix &amp;apos;C-a&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为了能让Tmux动态载入配置而不是重启，我们设一个快捷键&lt;prefix&gt;r来重新载入配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;bind r source-file ~/.tmux.conf \; display-message &amp;quot;Config reloaded&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/prefix&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>php中的坑</title>
    <link href="https://entimm.com/2016/09/18/php%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
    <id>https://entimm.com/2016/09/18/php中的坑/</id>
    <published>2016-09-18T15:25:11.000Z</published>
    <updated>2016-09-18T15:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路径的坑"><a href="#路径的坑" class="headerlink" title="路径的坑"></a>路径的坑</h3><p>$path = ‘/a/m/../b’;<br>假如 /a 存在<br>不管 /a/m 目录存不存在, mkdir 都能成功<br>但是如果不存在，那么 is_dir, realpath 等函数都会失败</p>
<h3 id="计算的坑"><a href="#计算的坑" class="headerlink" title="计算的坑"></a>计算的坑</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">5.1</span>;</div><div class="line">$b = <span class="number">5.1</span>;</div><div class="line">$size = <span class="number">100</span>;</div><div class="line">$t1 = intval($a = floatval($a) * $size);</div><div class="line">$t2 = intval($b = floatval($b) * $size);</div><div class="line">$t = rand($t1, $t2);</div><div class="line"><span class="keyword">echo</span> $t; <span class="comment">// 计算结果是509，而不是510</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;路径的坑&quot;&gt;&lt;a href=&quot;#路径的坑&quot; class=&quot;headerlink&quot; title=&quot;路径的坑&quot;&gt;&lt;/a&gt;路径的坑&lt;/h3&gt;&lt;p&gt;$path = ‘/a/m/../b’;&lt;br&gt;假如 /a 存在&lt;br&gt;不管 /a/m 目录存不存在, mkdir 都能成功
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图片资源优化</title>
    <link href="https://entimm.com/2016/09/18/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"/>
    <id>https://entimm.com/2016/09/18/图片资源优化/</id>
    <published>2016-09-18T15:23:34.000Z</published>
    <updated>2016-09-18T15:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>选择合适的图片格式</p>
<p> 原理：对图片格式转换，在画质可以接受的情况下达到更好的压缩比效果<br> 优势：减少图片加载流量，效果比较明显<br> 劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持，格式转换要考虑浏览器的兼容性</p>
</li>
<li><p>图片大小小于2KB时可使用base64编码代替图片</p>
</li>
<li><p>不同终端对同一个图片需求不一样，可以根据终端加载不同的图片来节省没必要的流量</p>
</li>
<li><p>使用css、svg、canvas或iconfont代替图片</p>
</li>
<li><p>合并图片：</p>
<p> 优势：可以有效的较少请求个数<br> 劣势：生成的图片体积较大，减少请求个数同时也增加了图片大小，不合理拆分将不利于并行加载</p>
</li>
<li><p>图片压缩</p>
<p> 原理：对图片进行无损、有损压缩，转为压缩后图片来实现<br> 优势：减少图片加载流量，效果比较明显<br> 劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持</p>
</li>
<li><p>使用 CDN</p>
<p> 使用参数自动调节图片质量和大小的，最关键的还是，CDN 的每 G 流量价格普遍比 VPS 按流量付费的价格要低得多！</p>
</li>
<li><p>部署到单独的服务器中</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;选择合适的图片格式&lt;/p&gt;
&lt;p&gt; 原理：对图片格式转换，在画质可以接受的情况下达到更好的压缩比效果&lt;br&gt; 优势：减少图片加载流量，效果比较明显&lt;br&gt; 劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持，格式转换要考虑浏览器的兼容性&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://entimm.com/2016/09/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://entimm.com/2016/09/17/设计模式/</id>
    <published>2016-09-17T08:13:07.000Z</published>
    <updated>2016-09-17T08:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3种基本设计模式"><a href="#3种基本设计模式" class="headerlink" title="3种基本设计模式"></a>3种基本设计模式</h3><ol>
<li>工厂模式，工厂方法或者类生成对象，而不是在代码中直接new</li>
<li>单例模式，使某个类的对象仅允许创建一个</li>
<li>注册模式，全局共享和交换对象</li>
</ol>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ol>
<li>在客户端与实体之间建立一个代理对象(proxy),客户端对实体进行操作全部委派给代理对象,隐藏实体的具体实现细节</li>
<li>proxy还可以与业务代码分离,部署到另外的服务器。业务代码中通过RPC来委派任务</li>
</ol>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><ol>
<li>在不需要了解内部实现的前提下,遍历一个聚合对象的内部元素</li>
<li>相比于传统的编程模式,迭代器模式可以隐藏遍历元素的所需的操作</li>
</ol>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><ol>
<li>可以动态的添加修改类的功能</li>
<li>一个类提供了一项功能，如果要修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法</li>
<li>使用装饰器模式，仅需在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><ol>
<li>当一个对象状态发生改变时，依赖它的对象全部会受到通知，并自动更新</li>
<li>场景: 一个事件发生后，要执行一连串更新操作。传统的编程方式就是在事件的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码</li>
<li>观察者模式实现了低耦合，非侵入的通知和更新机制</li>
</ol>
<h3 id="数据对象映射模式"><a href="#数据对象映射模式" class="headerlink" title="数据对象映射模式"></a>数据对象映射模式</h3><ol>
<li>数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作</li>
<li>在代码中实现数据对象映射操作模式，我们将实现一个ORM类，将复杂的SQL语句映射成对象属性的操作</li>
<li>结合使用数据对象映射模式、工厂模式、注册模式</li>
</ol>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ol>
<li>策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境</li>
<li>实际应用举例，假如一个电商网站系统，针对男性女性用户要各自<br>跳转到不同的商品类目，并且所有广告位展示不同的广告</li>
<li>使用策略模式可以实现IOC，依赖倒置、控制反转</li>
</ol>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ol>
<li>适配器模式，可以将截然不同的函数接口封装成统一的API</li>
<li>实际应用举例，PHP的数据库操作有mysql,mysqli,pdo，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache、redis、file、apc等不同的缓存函数，统一成一致</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;3种基本设计模式&quot;&gt;&lt;a href=&quot;#3种基本设计模式&quot; class=&quot;headerlink&quot; title=&quot;3种基本设计模式&quot;&gt;&lt;/a&gt;3种基本设计模式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;工厂模式，工厂方法或者类生成对象，而不是在代码中直接new&lt;/li&gt;
&lt;li&gt;单例模式，使某个类的对象仅允许创建一个&lt;/li&gt;
&lt;li&gt;注册模式，全局共享和交换对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在客户端与实体之间建立一个代理对象(proxy),客户端对实体进行操作全部委派给代理对象,隐藏实体的具体实现细节&lt;/li&gt;
&lt;li&gt;proxy还可以与业务代码分离,部署到另外的服务器。业务代码中通过RPC来委派任务&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在不需要了解内部实现的前提下,遍历一个聚合对象的内部元素&lt;/li&gt;
&lt;li&gt;相比于传统的编程模式,迭代器模式可以隐藏遍历元素的所需的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;装饰器模式&quot;&gt;&lt;a href=&quot;#装饰器模式&quot; class=&quot;headerlink&quot; title=&quot;装饰器模式&quot;&gt;&lt;/a&gt;装饰器模式&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高级 PHP</title>
    <link href="https://entimm.com/2016/09/16/%E9%AB%98%E7%BA%A7PHP/"/>
    <id>https://entimm.com/2016/09/16/高级PHP/</id>
    <published>2016-09-16T11:59:33.000Z</published>
    <updated>2016-09-16T11:59:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象5原则"><a href="#面向对象5原则" class="headerlink" title="面向对象5原则"></a>面向对象5原则</h2><h3 id="单一职责原则（single-resposibility-principle）"><a href="#单一职责原则（single-resposibility-principle）" class="headerlink" title="单一职责原则（single-resposibility principle）"></a>单一职责原则（single-resposibility principle）</h3><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化的原因</p>
<h3 id="开放-封闭原则（The-Open-Close-principle）"><a href="#开放-封闭原则（The-Open-Close-principle）" class="headerlink" title="开放-封闭原则（The Open-Close principle）"></a>开放-封闭原则（The Open-Close principle）</h3><p>其核心思想为：对扩展开放，对修改封闭<br>软件实体（类、模块、函数）应该是可扩展的，但是不可修改的。也就是说，对于扩展是开放的，对于更改是封闭的。怎样可能在不改动模块源代码的情况下去更改它的行为呢？怎样才能在无需对模块进行改动的情况下改变它的功能呢？关键是抽象！因此在进行面向对象设计时要尽量考虑接口封装机制、抽象机制和多态技术。该原则同样适合于非面向对象的方法，是软件工程设计方法的重要原则之一</p>
<h3 id="Liskov-替换原则（liskov-substitution-principle）"><a href="#Liskov-替换原则（liskov-substitution-principle）" class="headerlink" title="Liskov 替换原则（liskov-substitution principle）"></a>Liskov 替换原则（liskov-substitution principle）</h3><p>其核心思想：子类必须能够替换其基类<br>子类应当可以替换父类出现在父类能够出现的任何地方</p>
<h3 id="依赖倒置原则（dependency-inversion-principle）"><a href="#依赖倒置原则（dependency-inversion-principle）" class="headerlink" title="依赖倒置原则（dependency-inversion principle）"></a>依赖倒置原则（dependency-inversion principle）</h3><p>其核心思想：依赖于抽象<br>一个类不应该强依赖另外一个类，每个类对于另外一个类都是可替换的<br>1、高层模块不应该依赖于低层模块，二者都应该依赖于抽象。<br>2、抽象不应该依赖于细节。细节应该依赖于抽象。在进行业务设计时，于特定业务有关的依赖关系应该尽量依赖接口和抽象类，而不是依赖于具体类。具体类只负责相关业务的实现，修改具体类不影响与特定业务有关的依赖关系。</p>
<h3 id="接口分离原则（interface-segregation-principle）"><a href="#接口分离原则（interface-segregation-principle）" class="headerlink" title="接口分离原则（interface-segregation principle）"></a>接口分离原则（interface-segregation principle）</h3><p>其核心思想：使用多个小的专门的接口，而不要使用一个大的总接口<br>具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是运行中超出了你程序预期的一个东西。</p>
<p>异常就是一个意外，影响了你的程序正常运行。但是如果你用好异常，会让你的程序便于解耦，结构更加清晰明了。</p>
<p>异常对我们控制程序的流程来说非常重要。解耦了程序出现意想不到结果时信息传递的逻辑。每个业务模块发生异常最终通过 Laravel 的方便的异常处理，和友好的展示，并能根据情况来记录错误，这样让我们的程序更加健壮，方便开发和维护。</p>
<h2 id="异常-vs-if-else"><a href="#异常-vs-if-else" class="headerlink" title="异常 vs if_else"></a>异常 vs if_else</h2><p>把这个大函数分成了若干小函数，在这个小函数里面抛异常，大函数里面扑获异常，不用再一个一个的判断小函数的返回值</p>
<p>任何好的语言都应该提供完善的异常支持服务, 来使程序结构更优美可读行更好可维护,而不是靠一大堆的if else来控制程序的流程.</p>
<p>要有上下层的概念，在上下层逻辑处理中,throw 是 Current Role 反馈给 Upper Role，try/catch 是 Current Role 处理 Lower Role 反馈</p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>把业务逻辑处理部分抽象出来作为一层，这一层在M之上，C之下，名为 Logic</p>
<p>把可以作为公共的服务抽象出来作为一层，这一层不与任何一层耦合，仅提供自身的服务，名为Service<br>小到文件上传，下载，图片处理，储存<br>大到日志，错误处理，邮件，授权，队列，计划任务，支付，验证，加密，短信都可以做出单独的服务</p>
<p>业务变了，C层和M层都不需要改动，只需要改动中间的 Logic 就好了</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在Controller里面，做外部来的请求数据包的合法性校验和部分用户接口权限校验<br>用户相关逻辑放在logic层,做严格的数据合法性校验、业务逻辑约束校验、用户数据权限校验<br>在Model里面做数据的物理合法性校验</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性是面向对象设计的重要特性，它展现了动态绑定的功能,多态的功能可以让软件在开发和维护时，达到充分的延伸性<br>通俗理解:让具有继承关系的不同类对象，可以对相同名称的成员函数调用，产生不同的反应结果</p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><h3 id="RBAC（Role-Based-Access-Control）"><a href="#RBAC（Role-Based-Access-Control）" class="headerlink" title="RBAC（Role-Based Access Control）"></a>RBAC（Role-Based Access Control）</h3><p>基于角色的访问控制系统</p>
<ul>
<li>用户表</li>
<li>权限表</li>
<li>角色表</li>
<li>角色权限表</li>
<li>用户角色表</li>
</ul>
<h3 id="ACL（Access-Control-List）"><a href="#ACL（Access-Control-List）" class="headerlink" title="ACL（Access Control List）"></a>ACL（Access Control List）</h3><p>访问控制列表，是前几年盛行的一种权限设计，它的核心在于用户直接和权限挂钩</p>
<p>RBAC的核心是用户只和角色关联，而角色代表对了权限，这样设计的优势在于使得对用户而言，只需角色即可以，而某角色可以拥有各种各样的权限并可继承<br>ACL和RBAC相比缺点在于由于用户和权限直接挂钩，导致在授予时的复杂性，虽然可以利用组来简化这个复杂性，但仍然会导致系统不好理解，而且在取出判断用户是否有该权限时比较的困难，一定程度上影响了效率</p>
<p>ACL实质上是每一个权限接口维持一个权限列表，然后通过判断是否在列表中这个扁平快的方法，进行基础的权限控制，也有其不足：对于多人控制的某些系统，权限需要分为select，update，insert，delete等，人员需要分为管理员，用户，访客，超级管理员，这种情况下再使用ACL反而是增加工作量，增加后期维护难度，同时增加管理难度</p>
<p>在这种情况下，RBAC应运而生RBAC，基于组的权限控制，ACL的升级版</p>
<p>相比于ACL，RBAC的优势是将角色和角色绑定，将用户与权限之间的关联变为权限与角色之间的关联，从而简化了权限管理。当然普通的RBAC也有自身的缺点，就是权限是以角色为载体，单独用户的特殊的权限需要定制</p>
<h2 id="使用-OpCache-提升-PHP-5-5-程序性能"><a href="#使用-OpCache-提升-PHP-5-5-程序性能" class="headerlink" title="使用 OpCache 提升 PHP 5.5+ 程序性能"></a>使用 OpCache 提升 PHP 5.5+ 程序性能</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>PHP 5.5 以后内建了 OpCache , OpCache 的加速原理是把编译后的 bytecode 存储在内存里面, 避免重复编译 PHP 所造成的资源浪费.</p>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>修改 php.ini 文件,在文件最后面加入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">; 开关打开</div><div class="line">opcache.enable=1</div><div class="line"></div><div class="line">; 可用内存, 酌情而定, 单位 megabytes</div><div class="line">opcache.memory_consumption=256</div><div class="line"></div><div class="line">; 对多缓存文件限制, 命中率不到 100% 的话, 可以试着提高这个值</div><div class="line">opcache.max_accelerated_files=5000</div><div class="line"></div><div class="line">; Opcache 会在一定时间内去检查文件的修改时间, 这里设置检查的时间周期, 默认为 2, 定位为秒</div><div class="line">opcache.revalidate_freq=240</div></pre></td></tr></table></figure></p>
<h3 id="APC-VS-OpCache"><a href="#APC-VS-OpCache" class="headerlink" title="APC VS OpCache"></a>APC VS OpCache</h3><p>APC 是将要被遗弃的项目, PHP 5.5 都不支持, 而在 PHP 5.5 和 5.6 版本, OpCache 是默认内建的, 并且支持 5.2 到 5.4 的安装.</p>
<h3 id="关于composer-lock"><a href="#关于composer-lock" class="headerlink" title="关于composer.lock"></a>关于composer.lock</h3><h2 id="composer-lock"><a href="#composer-lock" class="headerlink" title="composer.lock"></a>composer.lock</h2><h3 id="什么是-composer-lock-文件"><a href="#什么是-composer-lock-文件" class="headerlink" title="什么是 composer.lock 文件?"></a>什么是 composer.lock 文件?</h3><p>composer.lock 文件是当你第一次使用 composer install 或者 执行 composer update 后生成的文件, 此文件里定义了当前项目的代码依赖, 还有最重要的, 这些代码依赖的对应的版本.</p>
<h3 id="composer-lock-文件作用是什么"><a href="#composer-lock-文件作用是什么" class="headerlink" title="composer.lock 文件作用是什么?"></a>composer.lock 文件作用是什么?</h3><p>默认情况下, 当执行 composer install 的时候, Composer 会检查当前项目是否有 composer.lock 文件, 如果有的话, 就会按照此文件去下载代码依赖和其指定的版本.</p>
<h3 id="把-composer-lock-文件加版本的好处有以下"><a href="#把-composer-lock-文件加版本的好处有以下" class="headerlink" title="把 composer.lock 文件加版本的好处有以下:"></a>把 composer.lock 文件加版本的好处有以下:</h3><p>团队开发的时, clone 下代码后, 使用 composer install 可以确保大家使用的依赖包都是同一个版本的, 避免没必要的混乱;<br>在一个现有的项目上开发的时候, 执行 composer update 后, 偶尔会发现刚刚更新了某个代码包把程序整挂了, 这个时候, 如果 composer.lock 是加入版本控制器的话, 直接一个 git diff 命令, 就可以查看到这次更新了那个包, 快速定位到问题的所在;<br>在线上部署的时候, 可以确保线上生成环境下使用所有代码是和开发时候使用的一致, 因为 composer.lock 会确保你在执行 composer install 命令后, 按照文件里面指定的版本去下载代码依赖包;</p>
<h2 id="php自身的性能优化"><a href="#php自身的性能优化" class="headerlink" title="php自身的性能优化"></a>php自身的性能优化</h2><ul>
<li>OPcache</li>
<li>通过 PHP 扩展代替原 PHP 代码中高频逻辑</li>
<li>Runtime优化:HHVM</li>
</ul>
<h3 id="php周边问题"><a href="#php周边问题" class="headerlink" title="php周边问题"></a>php周边问题</h3><ul>
<li>linux 运行环境</li>
<li>文件存储</li>
<li>数据库</li>
<li>缓存</li>
<li>网络</li>
</ul>
<h3 id="Disk-IO优化"><a href="#Disk-IO优化" class="headerlink" title="Disk IO优化"></a>Disk IO优化</h3><p>RAID0: 也称为条带，就是把多个磁盘链接成一个硬盘使用，这个级别IO最好<br>RAID1: 也称为镜像，要求至少有两个磁盘，每组磁盘存储的数据相同<br>RAID5: 也是把多个（最少3个）硬盘合并成1个逻辑盘使用，数据读写时建立就效验信息，并且奇偶效验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，利用剩下的数据和响应的奇偶效验信息去恢复被损坏的数据<br>RAID1+0: 就是RAID1和RAID0的结合。同时具备两个级别的优缺点。一般建议数据库使用这个级别</p>
<h3 id="PHP文件执行阶段"><a href="#PHP文件执行阶段" class="headerlink" title="PHP文件执行阶段"></a>PHP文件执行阶段</h3><p>语法分析-&gt;编译-&gt;运行</p>
<h3 id="配置与设计模式"><a href="#配置与设计模式" class="headerlink" title="配置与设计模式"></a>配置与设计模式</h3><ol>
<li>PHP中使用<code>ArrayAccess</code>实现配置文件的加载</li>
<li>在工厂方法中读取配置，生成可配置化的对象</li>
<li>使用装饰器模式实现权限验证，模板渲染，JSON串化</li>
<li>使用观察者模式实现数据更新事件的一系列更新操作</li>
<li>使用代理模式实现数据库的主从自动切换</li>
</ol>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul>
<li>模型: 数据和存储的封装</li>
<li>视图: 展示层的封装，如Web系统中的模板文件</li>
<li>控制器: 逻辑层的封装</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象5原则&quot;&gt;&lt;a href=&quot;#面向对象5原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象5原则&quot;&gt;&lt;/a&gt;面向对象5原则&lt;/h2&gt;&lt;h3 id=&quot;单一职责原则（single-resposibility-principle）&quot;&gt;&lt;a href=&quot;#单一职责原则（single-resposibility-principle）&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则（single-resposibility principle）&quot;&gt;&lt;/a&gt;单一职责原则（single-resposibility principle）&lt;/h3&gt;&lt;p&gt;其核心思想为：一个类，最好只做一件事，只有一个引起它的变化的原因&lt;/p&gt;
&lt;h3 id=&quot;开放-封闭原则（The-Open-Close-principle）&quot;&gt;&lt;a href=&quot;#开放-封闭原则（The-Open-Close-principle）&quot; class=&quot;headerlink&quot; title=&quot;开放-封闭原则（The Open-Close principle）&quot;&gt;&lt;/a&gt;开放-封闭原则（The Open-Close principle）&lt;/h3&gt;&lt;p&gt;其核心思想为：对扩展开放，对修改封闭&lt;br&gt;软件实体（类、模块、函数）应该是可扩展的，但是不可修改的。也就是说，对于扩展是开放的，对于更改是封闭的。怎样可能在不改动模块源代码的情况下去更改它的行为呢？怎样才能在无需对模块进行改动的情况下改变它的功能呢？关键是抽象！因此在进行面向对象设计时要尽量考虑接口封装机制、抽象机制和多态技术。该原则同样适合于非面向对象的方法，是软件工程设计方法的重要原则之一&lt;/p&gt;
&lt;h3 id=&quot;Liskov-替换原则（liskov-substitution-principle）&quot;&gt;&lt;a href=&quot;#Liskov-替换原则（liskov-substitution-principle）&quot; class=&quot;headerlink&quot; title=&quot;Liskov 替换原则（liskov-substitution principle）&quot;&gt;&lt;/a&gt;Liskov 替换原则（liskov-substitution principle）&lt;/h3&gt;&lt;p&gt;其核心思想：子类必须能够替换其基类&lt;br&gt;子类应当可以替换父类出现在父类能够出现的任何地方&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux相关操作</title>
    <link href="https://entimm.com/2016/09/15/linux/"/>
    <id>https://entimm.com/2016/09/15/linux/</id>
    <published>2016-09-15T10:02:33.000Z</published>
    <updated>2016-09-15T10:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>/etc/init.d/iptables stop<br>service iptables stop # 停止服务</p>
<h3 id="查看防火墙信息"><a href="#查看防火墙信息" class="headerlink" title="查看防火墙信息"></a>查看防火墙信息</h3><p>/etc/init.d/iptables status</p>
<h3 id="开放端口-8080"><a href="#开放端口-8080" class="headerlink" title="开放端口:8080"></a>开放端口:8080</h3><p>/sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT</p>
<h3 id="重启防火墙以便改动生效-或者直接重启系统"><a href="#重启防火墙以便改动生效-或者直接重启系统" class="headerlink" title="重启防火墙以便改动生效:(或者直接重启系统)"></a>重启防火墙以便改动生效:(或者直接重启系统)</h3><p>/etc/init.d/iptables restart</p>
<h3 id="将更改进行保存"><a href="#将更改进行保存" class="headerlink" title="将更改进行保存"></a>将更改进行保存</h3><p>/etc/rc.d/init.d/iptables save</p>
<p>另外直接在/etc/sysconfig/iptables中增加一行：<br>-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT</p>
<h2 id="在当前文件夹中查找字串"><a href="#在当前文件夹中查找字串" class="headerlink" title="在当前文件夹中查找字串"></a>在当前文件夹中查找字串</h2><p>grep ‘search_str’ ./ -r</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;防火墙&quot;&gt;&lt;a href=&quot;#防火墙&quot; class=&quot;headerlink&quot; title=&quot;防火墙&quot;&gt;&lt;/a&gt;防火墙&lt;/h2&gt;&lt;h3 id=&quot;关闭防火墙&quot;&gt;&lt;a href=&quot;#关闭防火墙&quot; class=&quot;headerlink&quot; title=&quot;关闭防火墙&quot;&gt;&lt;/a&gt;关闭防火墙&lt;/h3&gt;&lt;p&gt;/etc/init.d/iptables stop&lt;br&gt;service iptables stop # 停止服务&lt;/p&gt;
&lt;h3 id=&quot;查看防火墙信息&quot;&gt;&lt;a href=&quot;#查看防火墙信息&quot; class=&quot;headerlink&quot; title=&quot;查看防火墙信息&quot;&gt;&lt;/a&gt;查看防火墙信息&lt;/h3&gt;&lt;p&gt;/etc/init.d/iptables status&lt;/p&gt;
&lt;h3 id=&quot;开放端口-8080&quot;&gt;&lt;a href=&quot;#开放端口-8080&quot; class=&quot;headerlink&quot; title=&quot;开放端口:8080&quot;&gt;&lt;/a&gt;开放端口:8080&lt;/h3&gt;&lt;p&gt;/sbin/iptables -I INPUT -p tcp –dport 8080 -j ACCEPT&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过网址自动部署web</title>
    <link href="https://entimm.com/2016/09/15/%E9%80%9A%E8%BF%87%E7%BD%91%E5%9D%80%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2web/"/>
    <id>https://entimm.com/2016/09/15/通过网址自动部署web/</id>
    <published>2016-09-15T09:36:20.000Z</published>
    <updated>2016-09-15T09:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>部署代码至单独的web站点<br> <a href="https://github.com/markomarkovic/simple-php-git-deploy.git" target="_blank" rel="external">https://github.com/markomarkovic/simple-php-git-deploy.git</a></li>
<li>配置<code>www-data</code>用户<br> 改<code>/usr/sbin/nologin</code>=&gt;<code>/bin/bash</code>,且可找到<code>www-data</code>用户的目录:<code>/var/www</code></li>
<li>设置www-data登录密码<br> sudo passwd www-data</li>
<li>设置<code>/var/www</code>归属<br>sudo chown -R www-data:www-data /var/www/</li>
<li>切换到<code>www-data</code>用户<br> su /var/www</li>
<li>在<code>/var/www/.ssh</code>目录中生成ssh key<br> sudo -Hu www-data ssh-keygen -t rsa -C “entimm@gmail.com”</li>
<li>登录git托管网址，把<code>id_rsa.pub</code>公约贴上去</li>
<li>设置webhook</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;部署代码至单独的web站点&lt;br&gt; &lt;a href=&quot;https://github.com/markomarkovic/simple-php-git-deploy.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://githu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>很有用的一些技巧</title>
    <link href="https://entimm.com/2016/09/12/%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://entimm.com/2016/09/12/很有用的一些技巧/</id>
    <published>2016-09-12T11:31:55.000Z</published>
    <updated>2016-09-12T11:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在利用-xdebug-和-phpstorm-调试通过终端执行的-PHP-脚本时，在终端执行先语句，即可对该脚本进行调试"><a href="#在利用-xdebug-和-phpstorm-调试通过终端执行的-PHP-脚本时，在终端执行先语句，即可对该脚本进行调试" class="headerlink" title="在利用 xdebug 和 phpstorm 调试通过终端执行的 PHP 脚本时，在终端执行先语句，即可对该脚本进行调试"></a>在利用 xdebug 和 phpstorm 调试通过终端执行的 PHP 脚本时，在终端执行先语句，即可对该脚本进行调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export XDEBUG_CONFIG = &quot;idekey=PHPSTORM&quot;</div></pre></td></tr></table></figure>
<h3 id="通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码"><a href="#通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码" class="headerlink" title="通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码"></a>通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 先在本机生成 authentication keys，注意不能输入 passphrase</div><div class="line"># 这里假设 A 是本机，B是远端</div><div class="line">a@A:~&gt; ssh-keygen -t rsa</div><div class="line"></div><div class="line"># 然后登录 B，并建立一个目录 ~/.ssh</div><div class="line">a@A:~&gt; ssh b@B mkdir -p .ssh</div><div class="line"></div><div class="line"># 最后把 A 的 id_rsa.pub 追加到 B 的 ~/.ssh/authorized_keys 中去</div><div class="line">a@A:~&gt; cat ~/.ssh/id_rsa.pub | ssh b@B &apos;cat &gt;&gt; ~/.ssh/authorized_keys&apos;</div><div class="line"></div><div class="line"># 然后就成功了</div><div class="line">a@A:~&gt; ssh b@B</div></pre></td></tr></table></figure>
<h3 id="使用的-PHP-的内建服务器"><a href="#使用的-PHP-的内建服务器" class="headerlink" title="使用的 PHP 的内建服务器"></a>使用的 PHP 的内建服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S 主机名或地址@端口号 -t 目录</div></pre></td></tr></table></figure>
<h3 id="svn-检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用"><a href="#svn-检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用" class="headerlink" title="svn 检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用"></a>svn 检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn update --set-depth immediates</div></pre></td></tr></table></figure>
<h3 id="git-新建一个全新的空白分支"><a href="#git-新建一个全新的空白分支" class="headerlink" title="git 新建一个全新的空白分支"></a>git 新建一个全新的空白分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout --orphan 分支名</div><div class="line">git clean -f</div></pre></td></tr></table></figure>
<h3 id="针对手机端-google-chrome-的样式优化（很好看）"><a href="#针对手机端-google-chrome-的样式优化（很好看）" class="headerlink" title="针对手机端 google chrome 的样式优化（很好看）"></a>针对手机端 google chrome 的样式优化（很好看）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"theme-color"</span> <span class="attr">content</span>=<span class="string">"这里是你的 web 主题颜色"</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="注释技巧"><a href="#注释技巧" class="headerlink" title="注释技巧"></a>注释技巧</h3><ul>
<li><p>TODO<br>说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p>
</li>
<li><p>FIXME<br>说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>
</li>
<li><p>XXX<br>说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>
</li>
</ul>
<h3 id="正则匹配中文"><a href="#正则匹配中文" class="headerlink" title="正则匹配中文"></a>正则匹配中文</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!preg_match(<span class="string">"/^["</span>.chr(<span class="number">0xa1</span>).<span class="string">"-"</span>.chr(<span class="number">0xff</span>).<span class="string">"A-Za-z0-9_]+$/"</span>,$str)) <span class="comment">//GB2312汉字字母数字下划线正则表达式</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(!preg_match(<span class="string">"/^[\x&#123;4e00&#125;-\x&#123;9fa5&#125;A-Za-z0-9_]+$/u"</span>,$str)) <span class="comment">//UTF-8汉字字母数字下划线正则表达式</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在利用-xdebug-和-phpstorm-调试通过终端执行的-PHP-脚本时，在终端执行先语句，即可对该脚本进行调试&quot;&gt;&lt;a href=&quot;#在利用-xdebug-和-phpstorm-调试通过终端执行的-PHP-脚本时，在终端执行先语句，即可对该脚本进行调试&quot; class=&quot;headerlink&quot; title=&quot;在利用 xdebug 和 phpstorm 调试通过终端执行的 PHP 脚本时，在终端执行先语句，即可对该脚本进行调试&quot;&gt;&lt;/a&gt;在利用 xdebug 和 phpstorm 调试通过终端执行的 PHP 脚本时，在终端执行先语句，即可对该脚本进行调试&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;export XDEBUG_CONFIG = &amp;quot;idekey=PHPSTORM&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码&quot;&gt;&lt;a href=&quot;#通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码&quot; class=&quot;headerlink&quot; title=&quot;通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码&quot;&gt;&lt;/a&gt;通过SSH方式登录远程服务器时，通过下面方式免除每次都要输入密码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# 先在本机生成 authentication keys，注意不能输入 passphrase&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 这里假设 A 是本机，B是远端&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a@A:~&amp;gt; ssh-keygen -t rsa&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 然后登录 B，并建立一个目录 ~/.ssh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a@A:~&amp;gt; ssh b@B mkdir -p .ssh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 最后把 A 的 id_rsa.pub 追加到 B 的 ~/.ssh/authorized_keys 中去&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a@A:~&amp;gt; cat ~/.ssh/id_rsa.pub | ssh b@B &amp;apos;cat &amp;gt;&amp;gt; ~/.ssh/authorized_keys&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 然后就成功了&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a@A:~&amp;gt; ssh b@B&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用的-PHP-的内建服务器&quot;&gt;&lt;a href=&quot;#使用的-PHP-的内建服务器&quot; class=&quot;headerlink&quot; title=&quot;使用的 PHP 的内建服务器&quot;&gt;&lt;/a&gt;使用的 PHP 的内建服务器&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;php -S 主机名或地址@端口号 -t 目录&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;svn-检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用&quot;&gt;&lt;a href=&quot;#svn-检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用&quot; class=&quot;headerlink&quot; title=&quot;svn 检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用&quot;&gt;&lt;/a&gt;svn 检出当前目前下的文件或文件名，这在开发过程中不想检出全部数据时很有用&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试问题总结</title>
    <link href="https://entimm.com/2016/09/08/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://entimm.com/2016/09/08/面试问题总结/</id>
    <published>2016-09-08T15:52:47.000Z</published>
    <updated>2016-09-08T15:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php魔术方法-14项"><a href="#php魔术方法-14项" class="headerlink" title="php魔术方法(14项)"></a>php魔术方法(14项)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">__construct() 实例化类时自动调用.</div><div class="line">__destruct() 类对象使用结束时自动调用.</div><div class="line">__set() 在给未定义的属性赋值的时候调用.</div><div class="line">__get() 调用未定义的属性时候调用.</div><div class="line">__isset() 使用isset()或empty()函数时候会调用.</div><div class="line">__unset() 使用unset()时候会调用.</div><div class="line">__sleep() 使用serialize序列化时候调用.</div><div class="line">__wakeup() 使用unserialize反序列化的时候调用.</div><div class="line">__call() 调用一个不存在的方法的时候调用.</div><div class="line">__callStatic()调用一个不存在的静态方法是调用.</div><div class="line">__toString() 把对象转换成字符串的时候会调用.比如 echo.</div><div class="line">__invoke() 当尝试把对象当方法调用时调用.</div><div class="line">__set_state() 当使用var_export()函数时候调用.接受一个数组参数.</div><div class="line">__clone() 当使用clone复制一个对象时候调用.</div></pre></td></tr></table></figure>
<h2 id="HTTP协议中几个状态码的含义"><a href="#HTTP协议中几个状态码的含义" class="headerlink" title="HTTP协议中几个状态码的含义."></a>HTTP协议中几个状态码的含义.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">100 Continue  继续,一般在发送post请求时,已发送了http header之后服务端将返回此信息,表示确认,之后发送具体参数信息</div><div class="line">200 OK   正常返回信息</div><div class="line">201 Created  请求成功并且服务器创建了新的资源</div><div class="line">202 Accepted  服务器已接受请求,但尚未处理</div><div class="line">301 Moved Permanently  请求的网页已永久移动到新位置.</div><div class="line">302 Found  临时性重定向.</div><div class="line">303 See Other  临时性重定向,且总是使用 GET 请求新的 URI.</div><div class="line">304 Not Modified  自从上次请求后,请求的网页未修改过.</div><div class="line">400 Bad Request  服务器无法理解请求的格式,客户端不应当尝试再次使用相同的内容发起请求.</div><div class="line">401 Unauthorized  请求未授权.</div><div class="line">403 Forbidden  禁止访问.</div><div class="line">404 Not Found  找不到如何与 URI 相匹配的资源.</div><div class="line">500 Internal Server Error  最常见的服务器端错误.</div><div class="line">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）.</div><div class="line"></div><div class="line">100 Continue</div><div class="line">101 Switching Protocols</div><div class="line">200 OK</div><div class="line">201 Created</div><div class="line">202 Accepted</div><div class="line">203 Non-Authoritative Information</div><div class="line">204 No Content</div><div class="line">205 Reset Content</div><div class="line">206 Partial Content</div><div class="line">300 Multiple Choices</div><div class="line">301 Moved Permanently</div><div class="line">302 Found</div><div class="line">303 See Other</div><div class="line">304 Not Modified</div><div class="line">305 Use Proxy</div><div class="line">307 Temporary Redirect</div><div class="line">400 Bad Request</div><div class="line">401 Unauthorized</div><div class="line">402 Payment Required</div><div class="line">403 Forbidden</div><div class="line">404 Not Found</div><div class="line">405 Method Not Allowed</div><div class="line">406 Not Acceptable</div><div class="line">407 Proxy Authentication Required</div><div class="line">408 Request Time-out</div><div class="line">409 Conflict</div><div class="line">410 Gone</div><div class="line">411 Length Required</div><div class="line">412 Precondition Failed</div><div class="line">413 Request Entity Too Large</div><div class="line">414 Request-URI Too Large</div><div class="line">415 Unsupported Media Type</div><div class="line">416 Requested range not satisfiable</div><div class="line">417 Expectation Failed</div><div class="line">500 Internal Server Error</div><div class="line">501 Not Implemented</div><div class="line">502 Bad Gateway</div><div class="line">503 Service Unavailable</div><div class="line">504 Gateway Time-out</div><div class="line">505 HTTP Version not supported</div></pre></td></tr></table></figure>
<h2 id="语句include和require的区别"><a href="#语句include和require的区别" class="headerlink" title="语句include和require的区别"></a>语句include和require的区别</h2><p>在失败的时候：<br><code>include</code> 产生一个 <code>warning</code> ,而 <code>require</code> 直接产生错误中断;</p>
<p><code>require</code> 在运行前载入;<br><code>include</code> 在运行时载入;</p>
<p><code>require_once</code> 和 <code>include_once</code> 可以避免重复包含同一文件.</p>
<p>如果网站框架的设计能避免重复引用的话,推荐用include/require,<br>因为他们比_once速度稍快. </p>
<h2 id="事务的特征-ACID"><a href="#事务的特征-ACID" class="headerlink" title="事务的特征(ACID)"></a>事务的特征(ACID)</h2><ul>
<li>原子性(Atomicity) 构成事务的所有事件要么都完成要么都当什么也没发生过</li>
<li>一致性(Consistency) 事务的结果应该符合预期，不应当超出预期之外导致不合理的结果</li>
<li>隔离性(Isolation) 未完成的事务应当对其它事务不构成影响</li>
<li>持久性(Durability) 事务的结果应当被永久保存下来</li>
</ul>
<h2 id="TCP传输的三次握手"><a href="#TCP传输的三次握手" class="headerlink" title="TCP传输的三次握手"></a>TCP传输的三次握手</h2><p>发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示确认。<br>最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，<code>TCP</code>协议会再次以相同的顺序发送相同的数据包。</p>
<h2 id="断开一个TCP连接则需要”四次握手”"><a href="#断开一个TCP连接则需要”四次握手”" class="headerlink" title="断开一个TCP连接则需要”四次握手”"></a>断开一个TCP连接则需要”四次握手”</h2><ul>
<li><p>第一次握手：主动关闭方发送一个<code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了<br>(当然，在fin包之前发送出去的数据，如果没有收到对应的<code>ack</code>确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</p>
</li>
<li><p>第二次握手：被动关闭方收到<code>FIN</code>包后，发送一个<code>ACK</code>给对方，确认序号为收到序号<code>+1</code>（与<code>SYN</code>相同，一个<code>FIN</code>占用一个序号）。</p>
</li>
<li><p>第三次握手：被动关闭方发送一个<code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
</li>
<li><p>第四次握手：主动关闭方收到<code>FIN</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<code>TCP</code>连接必须要经过三次“对话”才能建立起来</p>
<p><code>UDP</code>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h2 id="redis支持的数据类型"><a href="#redis支持的数据类型" class="headerlink" title="redis支持的数据类型"></a>redis支持的数据类型</h2><ul>
<li>string</li>
<li>list</li>
<li>set</li>
<li>order set</li>
<li>hash</li>
</ul>
<h2 id="asp-php-jsp的优缺点"><a href="#asp-php-jsp的优缺点" class="headerlink" title="asp,php,jsp的优缺点"></a>asp,php,jsp的优缺点</h2><p>asp: 闭源且不跨平台<br>php: 开源且跨平台，简单快速，作为网站初期的首选<br>jsp: </p>
<h3 id="这个题"><a href="#这个题" class="headerlink" title="这个题"></a>这个题</h3><p>如果 uid 值为 10,2,5,6,3 的记录存在，那么 select uid from user where uid in (10,2,5,6,3);<br>结果顺序为按 uid 升序排列</p>
<h2 id="php之multicurl"><a href="#php之multicurl" class="headerlink" title="php之multicurl"></a>php之multicurl</h2><p>multicurl所有的多线程就是异步、网络io支持并发，http请求支持并发<br>pthread是真正正宗的多线程，也是php唯一的多线程</p>
<h2 id="php优化"><a href="#php优化" class="headerlink" title="php优化"></a>php优化</h2><ul>
<li>CPU 密集部分用 C++ 或者 C 写 PHP 的扩展模块。</li>
<li>OPcache 通过将PHP脚本预编译的字节码存储到共享内存中来提升PHP的性能,省去了每次加载和解析PHP脚本的开销。</li>
</ul>
<h2 id="php版本的差异"><a href="#php版本的差异" class="headerlink" title="php版本的差异"></a>php版本的差异</h2><ul>
<li>在 PHP 5.5 之前，empty() 仅支持变量；5.5以后支持表达式了</li>
</ul>
<h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">错误的写法</div><div class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> uid <span class="keyword">where</span> <span class="keyword">count</span>(*) &gt; <span class="number">60</span>;</div><div class="line">`where` 子句后面不能跟聚合条件</div><div class="line">`group by` 应该写在 `where` 子句后面</div><div class="line">这种情况应该用 `having`</div><div class="line"></div><div class="line">正确的写法</div><div class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> uid <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">60</span>;</div></pre></td></tr></table></figure>
<h2 id="get-vs-post"><a href="#get-vs-post" class="headerlink" title="get vs post"></a>get vs post</h2><ul>
<li>get 数据量长度受限制，这主要是受 url 长度限制</li>
<li>安全</li>
<li>get限制表单中数据集的范围为asc2码，而post可以支持整个iso10646字符集</li>
</ul>
<h2 id="echo-print-print-r-的区别"><a href="#echo-print-print-r-的区别" class="headerlink" title="echo(),print(),print_r()的区别"></a>echo(),print(),print_r()的区别</h2><p>echo是语言结构，没有返回值<br>print是函数，有返回值<br>print_r是函数，递归调用，用于输出数组对象</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>方法一：php函数跳转,缺点，header头之前不能有输出，跳转后的程序继续执行，可用exit中断执行后面的程序。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Header(<span class="string">"Location: 网址"</span>);     <span class="comment">//直接跳转</span></div><div class="line">header(<span class="string">"refresh:3;url=网址"</span>); <span class="comment">//三秒后跳转</span></div></pre></td></tr></table></figure></p>
<p>方法二：利用meta<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;meta http-equiv=refresh content='0; url=网址'&gt;"</span>;</div></pre></td></tr></table></figure></p>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaddir1</span><span class="params">($dirname)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>($handle=opendir($dirname))&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">false</span>!==($files=readdir($handle)))&#123;</div><div class="line">            <span class="keyword">if</span>($files!=<span class="string">"."</span>&amp;&amp;$files!=<span class="string">".."</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(is_file($dirname.<span class="string">'/'</span>.$files))&#123;</div><div class="line">                    <span class="keyword">echo</span> $dirname.<span class="string">'/'</span>.$files.<span class="string">'&lt;br&gt;'</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(is_dir($dirname.<span class="string">"/"</span>.$files))&#123;</div><div class="line">                    loaddir($dirname.<span class="string">"/"</span>.$files);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaddir2</span><span class="params">($path)</span></span></div><div class="line">&#123;</div><div class="line">    $files = <span class="keyword">array</span>();</div><div class="line">    <span class="keyword">if</span>($handle = opendir($path))&#123;</div><div class="line">        <span class="keyword">while</span>(($f = readdir($handle)) !== <span class="keyword">false</span>)&#123;</div><div class="line">            $p = $path .<span class="string">'/'</span>. $f;</div><div class="line">            <span class="keyword">if</span>($f == <span class="string">'..'</span> || $f == <span class="string">'.'</span>) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(is_file($p))&#123;</div><div class="line">                $files[] = $f;</div><div class="line">            &#125;<span class="keyword">elseif</span>(is_dir($p))&#123;</div><div class="line">                $files[$f] = myscandir($p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        closedir($handle);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $files;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="限制上传文件大小"><a href="#限制上传文件大小" class="headerlink" title="限制上传文件大小"></a>限制上传文件大小</h2><ul>
<li>客户端的隐藏域MAX_FILE_SIZE的数值（可以被绕开）。</li>
<li>服务器端的upload_max_filesize，post_max_size和memory_limit。这几项不能够用脚本来设置。</li>
</ul>
<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>a.删除没有任何订单客户:DELETE FROM customerinfo WHERE customerid NOT in (SELECT customerid FROM orderinfo)<br>b.提取所有没有订单客户:SELECT <em> FROM customerinfo WHERE customerid NOT in (SELECT customerid FROM orderinfo)<br>c.提高b的速度优化:SELECT </em> FROM customerinfo LEFT JOIN orderid ON customerinfo.customerid=orderinfo.customerid<br>WHERE orderinfo.customerid IS NULL</p>
<h2 id="fopen打开文件"><a href="#fopen打开文件" class="headerlink" title="fopen打开文件"></a>fopen打开文件</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$readcontents = fopen(<span class="string">'http://www.phpres.com/index.html'</span>, <span class="string">'rb'</span>);</div><div class="line">$contents = stream_get_contents($readcontents);</div><div class="line">fclose($readcontents);</div><div class="line"><span class="keyword">echo</span> $contents;</div></pre></td></tr></table></figure>
<h2 id="char-vs-varchar"><a href="#char-vs-varchar" class="headerlink" title="char vs varchar"></a>char vs varchar</h2><p>Varchar是变长，节省存储空间，char是固定长度。查找效率要char型快，因为varchar是非定长，必须先查找长度，然后进行数据的提取，比char定长类型多了一个步骤，所以效率低一些</p>
<h2 id="这些这些协议的全称和中文解释（都是工作在应用层）"><a href="#这些这些协议的全称和中文解释（都是工作在应用层）" class="headerlink" title="这些这些协议的全称和中文解释（都是工作在应用层）"></a>这些这些协议的全称和中文解释（都是工作在应用层）</h2><p>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议<br>POP3 (Post Office Protocol 3) 邮局协议第3版<br>HTTP (Hypertext Transfer Protocol) 超文本传输协议<br>FTP   (File Transfer Protocol）文件传输协议<br>DNS   (Domain Name System and Domain Name Service protocol) 域名系统（服务）协议</p>
<h2 id="OSI七层网络模型的名称，由下到上"><a href="#OSI七层网络模型的名称，由下到上" class="headerlink" title="OSI七层网络模型的名称，由下到上"></a>OSI七层网络模型的名称，由下到上</h2><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h2 id="find命令和grep命令的区别"><a href="#find命令和grep命令的区别" class="headerlink" title="find命令和grep命令的区别"></a>find命令和grep命令的区别</h2><p>find：按照文件名查找<br>grep：按照文件内容查找</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php魔术方法-14项&quot;&gt;&lt;a href=&quot;#php魔术方法-14项&quot; class=&quot;headerlink&quot; title=&quot;php魔术方法(14项)&quot;&gt;&lt;/a&gt;php魔术方法(14项)&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;__construct() 实例化类时自动调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__destruct() 类对象使用结束时自动调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__set() 在给未定义的属性赋值的时候调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__get() 调用未定义的属性时候调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__isset() 使用isset()或empty()函数时候会调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__unset() 使用unset()时候会调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__sleep() 使用serialize序列化时候调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__wakeup() 使用unserialize反序列化的时候调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__call() 调用一个不存在的方法的时候调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__callStatic()调用一个不存在的静态方法是调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__toString() 把对象转换成字符串的时候会调用.比如 echo.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__invoke() 当尝试把对象当方法调用时调用.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__set_state() 当使用var_export()函数时候调用.接受一个数组参数.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;__clone() 当使用clone复制一个对象时候调用.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;HTTP协议中几个状态码的含义&quot;&gt;&lt;a href=&quot;#HTTP协议中几个状态码的含义&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议中几个状态码的含义.&quot;&gt;&lt;/a&gt;HTTP协议中几个状态码的含义.&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;100 Continue  继续,一般在发送post请求时,已发送了http header之后服务端将返回此信息,表示确认,之后发送具体参数信息&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;200 OK   正常返回信息&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;201 Created  请求成功并且服务器创建了新的资源&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;202 Accepted  服务器已接受请求,但尚未处理&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;301 Moved Permanently  请求的网页已永久移动到新位置.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;302 Found  临时性重定向.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;303 See Other  临时性重定向,且总是使用 GET 请求新的 URI.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;304 Not Modified  自从上次请求后,请求的网页未修改过.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;400 Bad Request  服务器无法理解请求的格式,客户端不应当尝试再次使用相同的内容发起请求.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;401 Unauthorized  请求未授权.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;403 Forbidden  禁止访问.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;404 Not Found  找不到如何与 URI 相匹配的资源.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;500 Internal Server Error  最常见的服务器端错误.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;100 Continue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;101 Switching Protocols&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;200 OK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;201 Created&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;202 Accepted&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;203 Non-Authoritative Information&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;204 No Content&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;205 Reset Content&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;206 Partial Content&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;300 Multiple Choices&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;301 Moved Permanently&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;302 Found&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;303 See Other&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;304 Not Modified&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;305 Use Proxy&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;307 Temporary Redirect&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;400 Bad Request&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;401 Unauthorized&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;402 Payment Required&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;403 Forbidden&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;404 Not Found&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;405 Method Not Allowed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;406 Not Acceptable&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;407 Proxy Authentication Required&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;408 Request Time-out&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;409 Conflict&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;410 Gone&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;411 Length Required&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;412 Precondition Failed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;413 Request Entity Too Large&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;414 Request-URI Too Large&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;415 Unsupported Media Type&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;416 Requested range not satisfiable&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;417 Expectation Failed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;500 Internal Server Error&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;501 Not Implemented&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;502 Bad Gateway&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;503 Service Unavailable&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;504 Gateway Time-out&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;505 HTTP Version not supported&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;语句include和require的区别&quot;&gt;&lt;a href=&quot;#语句include和require的区别&quot; class=&quot;headerlink&quot; title=&quot;语句include和require的区别&quot;&gt;&lt;/a&gt;语句include和require的区别&lt;/h2&gt;&lt;p&gt;在失败的时候：&lt;br&gt;&lt;code&gt;include&lt;/code&gt; 产生一个 &lt;code&gt;warning&lt;/code&gt; ,而 &lt;code&gt;require&lt;/code&gt; 直接产生错误中断;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt; 在运行前载入;&lt;br&gt;&lt;code&gt;include&lt;/code&gt; 在运行时载入;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试可能会被问到的问题</title>
    <link href="https://entimm.com/2016/09/08/%E9%9D%A2%E8%AF%95%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://entimm.com/2016/09/08/面试可能会问到的问题/</id>
    <published>2016-09-08T15:47:56.000Z</published>
    <updated>2016-09-08T15:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象-vs-接口"><a href="#抽象-vs-接口" class="headerlink" title="抽象 vs 接口"></a>抽象 vs 接口</h3><p>抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。<br>抽象类是通过关键字 abstract 来声明的。<br>抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法，<br>抽象方法没有方法体，该方法天生就是要被子类重写的。<br>抽象方法的格式为：abstract function abstractMethod();</p>
<p>因为php中只支持单继承，如果想实现多重继承，就要使用接口。也就是说子类可以实现多个接口。<br>接口是通过interface关键字来声明的，接口中的成员常量和方法都是public的，方法可以不写关键字public，<br>接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。</p>
<p>抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽象类还是接口要看具体实现。<br>子类继承抽象类使用extends，子类实现接口使用implements。</p>
<h3 id="文件上传注意事项"><a href="#文件上传注意事项" class="headerlink" title="文件上传注意事项"></a>文件上传注意事项</h3><ol>
<li>首现要在php.ini中开启文件上传；</li>
<li>在php.ini中有一个允许上传的最大值，默认是2MB。必要的时候可以更改；</li>
<li>上传表单一定要记住在form标签中写上enctype=”multipart/form-data”；</li>
</ol>
<h3 id="cookie作用"><a href="#cookie作用" class="headerlink" title="cookie作用"></a>cookie作用</h3><ol>
<li>记录用户访问的部分信息</li>
<li>在页面间传递变量</li>
</ol>
<h3 id="php-的数据类型"><a href="#php-的数据类型" class="headerlink" title="php 的数据类型"></a>php 的数据类型</h3><p>php支持8种原始数据类型。<br>包括：<br>    四种标量类型（布尔型boolean，整型interger，浮点型float/double , 字符串string）<br>    两种复合类型(数组array ， 对象object)<br>    两种特殊类型（资源resource，NULL）</p>
<h3 id="页面乱码处理"><a href="#页面乱码处理" class="headerlink" title="页面乱码处理"></a>页面乱码处理</h3><ol>
<li>查看当前页面meta标签的charset</li>
<li>header函数指定的charset</li>
<li>数据库的字符集</li>
</ol>
<h3 id="ajax缺点"><a href="#ajax缺点" class="headerlink" title="ajax缺点"></a>ajax缺点</h3><p>不利于seo推广优化，因为搜索引擎无法直接访问到ajax请求的内容</p>
<h3 id="字符串转整型"><a href="#字符串转整型" class="headerlink" title="字符串转整型"></a>字符串转整型</h3><ol>
<li>强制类型转换</li>
<li>settype(字符串变量,整型)</li>
<li>intval(字符串变量)</li>
</ol>
<h3 id="处理正则表达式"><a href="#处理正则表达式" class="headerlink" title="处理正则表达式"></a>处理正则表达式</h3><pre><code>preg_quote -- 转义正则表达式字符 正则表达式的特殊字符包括：. \ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : -
preg_replace -- 执行正则表达式的搜索和替换
preg_replace_callback -- 用回调函数执行正则表达式的搜索和替换
preg_split -- 用正则表达式分割字符串
</code></pre><h3 id="字符串的常用函数"><a href="#字符串的常用函数" class="headerlink" title="字符串的常用函数"></a>字符串的常用函数</h3><pre><code>trim();--去除空格
strlen();--字符串长度
substr();--截取字符串
str_replace();--替换字符串函数
substr_replace() -- 对指定字符串中的部分字符串进行替换
strstr();--检索字符串函数
explode();--分割字符串函数
strcasecmp();--比较字符串函数
</code></pre><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h3><p>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同<br>进程的颗粒度太大，每次都要有上下文环境的调入，保存，调出。<br>线程是共享了进程的上下文环境，的更为细小的CPU时间段</p>
<h2 id="留意一下"><a href="#留意一下" class="headerlink" title="留意一下"></a>留意一下</h2><ul>
<li>count 可以递归计算数组</li>
<li>echo可以一次输出多个值，中间用逗号隔开。而print一次只能输出一个值</li>
<li>include 有返回值,require 没有</li>
<li>当对一个不可见的对象属性使用empty() 时，__isset()方法如果存在的话，它将会被调用</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象-vs-接口&quot;&gt;&lt;a href=&quot;#抽象-vs-接口&quot; class=&quot;headerlink&quot; title=&quot;抽象 vs 接口&quot;&gt;&lt;/a&gt;抽象 vs 接口&lt;/h3&gt;&lt;p&gt;抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。&lt;br&gt;抽象类是通过关键字 abstract 来声明的。&lt;br&gt;抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法，&lt;br&gt;抽象方法没有方法体，该方法天生就是要被子类重写的。&lt;br&gt;抽象方法的格式为：abstract function abstractMethod();&lt;/p&gt;
&lt;p&gt;因为php中只支持单继承，如果想实现多重继承，就要使用接口。也就是说子类可以实现多个接口。&lt;br&gt;接口是通过interface关键字来声明的，接口中的成员常量和方法都是public的，方法可以不写关键字public，&lt;br&gt;接口中的方法也是没有方法体。接口中的方法也天生就是要被子类实现的。&lt;/p&gt;
&lt;p&gt;抽象类和接口实现的功能十分相似，最大的不同是接口能实现多继承。在应用中选择抽象类还是接口要看具体实现。&lt;br&gt;子类继承抽象类使用extends，子类实现接口使用implements。&lt;/p&gt;
&lt;h3 id=&quot;文件上传注意事项&quot;&gt;&lt;a href=&quot;#文件上传注意事项&quot; class=&quot;headerlink&quot; title=&quot;文件上传注意事项&quot;&gt;&lt;/a&gt;文件上传注意事项&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首现要在php.ini中开启文件上传；&lt;/li&gt;
&lt;li&gt;在php.ini中有一个允许上传的最大值，默认是2MB。必要的时候可以更改；&lt;/li&gt;
&lt;li&gt;上传表单一定要记住在form标签中写上enctype=”multipart/form-data”；&lt;/li&gt;
&lt;/ol&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cgi、FastCgi 与 PHP-FPM</title>
    <link href="https://entimm.com/2016/09/08/FastCgi%20%E4%B8%8E%20PHP-FPM%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://entimm.com/2016/09/08/FastCgi 与 PHP-FPM 之间的区别/</id>
    <published>2016-09-08T15:42:47.000Z</published>
    <updated>2016-09-08T15:42:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CGI-的作用"><a href="#CGI-的作用" class="headerlink" title="CGI 的作用"></a>CGI 的作用</h2><p>web server（比如说 nginx）只是内容的分发者。</p>
<ul>
<li>如果请求 <code>/index.html</code>，那么 web server 会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</li>
<li>如果现在请求的是 <code>/index.php</code>，根据配置文件，nginx 知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理后交给 PHP 解析器。Nginx 会传哪些数据给 PHP 解析器呢？url、查询字符串、POST 数据、HTTP header等等，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。</li>
</ul>
<p>当 web server 收到 <code>/index.php</code> 这个请求后，会启动对应的 CGI 程序，这里就是 PHP 的解析器。接下来 PHP 解析器会解析 php.ini 文件，初始化执行环境，然后处理请求，再以规定 CGI 规定的格式返回处理后的结果，退出进程。web server 再把结果返回给浏览器。</p>
<h2 id="fastCgi-是什么"><a href="#fastCgi-是什么" class="headerlink" title="fastCgi 是什么"></a>fastCgi 是什么</h2><p>fastCgi 是用来提高 CGI 程序性能的。</p>
<p>那么 CGI 程序的性能问题在哪呢？”PHP 解析器会解析 php.ini 文件，初始化执行环境”，就是这里了。标准的 CGI 对每个请求都会执行这些步骤，所以处理每个请求的时间会比较长。</p>
<p>那么 fastCgi 是怎么做的呢？首先，fastCgi 会先启一个 master，解析配置文件，初始化执行环境，然后再启动多个 worker。当请求过来时，master 会传递给一个 worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当 worker 不够用时，master 可以根据配置预先启动几个 worker 等着；当然空闲 worker 太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是 fastCgi 对进程的管理。</p>
<h2 id="PHP-FPM-是什么"><a href="#PHP-FPM-是什么" class="headerlink" title="PHP-FPM 是什么"></a>PHP-FPM 是什么</h2><p>PHP-FPM 是一个实现了 FastCgi 的程序，被 PHP 官方收录。</p>
<p>PHP 的解释器是 php-cgi，它只是个 CGI 程序，只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CGI-的作用&quot;&gt;&lt;a href=&quot;#CGI-的作用&quot; class=&quot;headerlink&quot; title=&quot;CGI 的作用&quot;&gt;&lt;/a&gt;CGI 的作用&lt;/h2&gt;&lt;p&gt;web server（比如说 nginx）只是内容的分发者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果请求 &lt;code&gt;/index.html&lt;/code&gt;，那么 web server 会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。&lt;/li&gt;
&lt;li&gt;如果现在请求的是 &lt;code&gt;/index.php&lt;/code&gt;，根据配置文件，nginx 知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理后交给 PHP 解析器。Nginx 会传哪些数据给 PHP 解析器呢？url、查询字符串、POST 数据、HTTP header等等，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 web server 收到 &lt;code&gt;/index.php&lt;/code&gt; 这个请求后，会启动对应的 CGI 程序，这里就是 PHP 的解析器。接下来 PHP 解析器会解析 php.ini 文件，初始化执行环境，然后处理请求，再以规定 CGI 规定的格式返回处理后的结果，退出进程。web server 再把结果返回给浏览器。&lt;/p&gt;
&lt;h2 id=&quot;fastCgi-是什么&quot;&gt;&lt;a href=&quot;#fastCgi-是什么&quot; class=&quot;headerlink&quot; title=&quot;fastCgi 是什么&quot;&gt;&lt;/a&gt;fastCgi 是什么&lt;/h2&gt;&lt;p&gt;fastCgi 是用来提高 CGI 程序性能的。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web安全</title>
    <link href="https://entimm.com/2016/09/08/web%E5%AE%89%E5%85%A8/"/>
    <id>https://entimm.com/2016/09/08/web安全/</id>
    <published>2016-09-08T03:51:16.000Z</published>
    <updated>2016-09-08T03:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>http 协议下的网络连接都是基于明文的，信息很有可能被泄露篡改<br>理论上 https 是安全的</p>
<h3 id="XSS-Cross-Site-Script"><a href="#XSS-Cross-Site-Script" class="headerlink" title="XSS(Cross-Site Script)"></a>XSS(Cross-Site Script)</h3><p>跨站脚本攻击本质上是一种注入攻击<br>简单的说就是利用各种手段把恶意代码添加到网页中，并让受害者执行这段脚本。 XSS 能做用户使用浏览器能做的一切事情。可以看到同源策略无法保证不受 XSS 攻击，因为此时攻击者就在同源之内。</p>
<p>可以分为以下两类：<br>client(客户端型)<br>server(服务端型)<br>当一端 XSS 代码是在服务端被插入的，那么这就是服务端型 XSS ，同理，如果代码在客户端插入，就是客户端型 XSS 。</p>
<p>其实只要做好无论任何情况下保证代码不被执行就能完全杜绝 XSS 攻击<br>任何时候都不要把不受信任的数据直接插入到 dom 中的任何位置,一定要做转义。</p>
<h3 id="Http-Only"><a href="#Http-Only" class="headerlink" title="Http-Only"></a>Http-Only</h3><p>使用 Http-only 保护 cookie ，可以保证即使发生了 XSS ，用户的 cookie 也是安全的。使用 Http-only 保护的 cookie 是不会被 javascript 读写的。</p>
<h3 id="CSP-Content-Security-Policy"><a href="#CSP-Content-Security-Policy" class="headerlink" title="CSP(Content Security Policy)"></a>CSP(Content Security Policy)</h3><p>CSP 的作用是限制一个页面的行为不论是否是 javacript 控制的。</p>
<p>如何引入 CSP 呢？</p>
<p>2.7.1 通过 response 头</p>
<p>//只允许脚本从本源加载 Content-Security-Policy: script-src ‘self’<br>2.7.2 通过 html 的 meta 标签</p>
<p>//作用同上</p>
<meta http-equiv="Content-Security-Policy" content="script-src 'self'">

<p>那么 CSP 除了限制 script-src 之外还能限制什么呢？</p>
<p>base-uri:限制这篇文档的 uri ；<br>child-src:限制子窗口的源(iframe 、弹窗等),取代 frame-src ；<br>connect-src:限制脚本可以访问的源；<br>font-src:限制字体的源；<br>form-action:限制表单能够提交到的源；<br>frame-ancestors:限制了当前页面可以被哪些页面以 iframe,frame,object 等方式加载；<br>frame-src:deprecated with child-src,限制了当前页面可以加载哪些源，与 frame-ancestors 对应；<br>img-src:限制图片可以从哪些源加载；<br>media-src:限制 video,audio, source,track 能够从哪些源加载；<br>object-src:限制插件可以从哪些源加载；<br>sandbox:强制打开沙盒模式；</p>
<p>可以看出， CSP 是一个强大的策略，几乎可以限制了所有能够用到的资源的来源。使用好 CSP 可以很大成都降低 XSS 带来的风险。<br>另外， CSP 还提供一个报告的头 Content-Security-Policy-Report-Only ，使用这个头浏览器向服务器报告 CSP 状态，细节先不讨论。</p>
<p>Content-Security-Policy-Report-Only:script-src’self’;<br>report-uri/csp-report-endpoint/</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token 必须随机生成，并且有过期时间</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;https&quot;&gt;&lt;a href=&quot;#https&quot; class=&quot;headerlink&quot; title=&quot;https&quot;&gt;&lt;/a&gt;https&lt;/h3&gt;&lt;p&gt;http 协议下的网络连接都是基于明文的，信息很有可能被泄露篡改&lt;br&gt;理论上 https 是安全的&lt;/p&gt;
&lt;h3 id=&quot;XSS-Cross-Site-Script&quot;&gt;&lt;a href=&quot;#XSS-Cross-Site-Script&quot; class=&quot;headerlink&quot; title=&quot;XSS(Cross-Site Script)&quot;&gt;&lt;/a&gt;XSS(Cross-Site Script)&lt;/h3&gt;&lt;p&gt;跨站脚本攻击本质上是一种注入攻击&lt;br&gt;简单的说就是利用各种手段把恶意代码添加到网页中，并让受害者执行这段脚本。 XSS 能做用户使用浏览器能做的一切事情。可以看到同源策略无法保证不受 XSS 攻击，因为此时攻击者就在同源之内。&lt;/p&gt;
&lt;p&gt;可以分为以下两类：&lt;br&gt;client(客户端型)&lt;br&gt;server(服务端型)&lt;br&gt;当一端 XSS 代码是在服务端被插入的，那么这就是服务端型 XSS ，同理，如果代码在客户端插入，就是客户端型 XSS 。&lt;/p&gt;
&lt;p&gt;其实只要做好无论任何情况下保证代码不被执行就能完全杜绝 XSS 攻击&lt;br&gt;任何时候都不要把不受信任的数据直接插入到 dom 中的任何位置,一定要做转义。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql知识</title>
    <link href="https://entimm.com/2016/09/08/mysql/"/>
    <id>https://entimm.com/2016/09/08/mysql/</id>
    <published>2016-09-07T16:10:30.000Z</published>
    <updated>2016-09-07T16:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL存储引擎-MyISAM-和-InnoDB-的区别"><a href="#MySQL存储引擎-MyISAM-和-InnoDB-的区别" class="headerlink" title="MySQL存储引擎 MyISAM 和 InnoDB 的区别"></a>MySQL存储引擎 MyISAM 和 InnoDB 的区别</h2><ul>
<li>MyISAM类型不支持事务处理等高级处理,而InnoDB类型支持.</li>
<li>InnoDB不支持FULLTEXT类型的索引.</li>
<li>InnoDB中不保存表的具体行数,但是MyISAM只要简单的读出保存好的行数即可.</li>
<li>MyISAM支持表锁，只有读读之间是并发的，写写之间和读写之间（读和插入之间是可以并发的，去设置concurrent_insert参数，定期执行表优化操作，更新操作就没有办法了）是串行的，所以写起来慢；InnoDB支持行锁，这个一般指的是sql用到索引的时候，行锁是加在索引上的，不是加在数据记录上的，如果sql没有用到索引，仍然会锁定表，普通的select是不需要锁的</li>
<li>MyISAM索引btree上的节点是一个指向数据物理位置的指针，所以查找起来很快；nnodb索引节点存的则是数据的主键，所以需要根据主键二次查找</li>
<li>因为在使用索引的时候用的是行锁，锁的粒度小，竞争相同锁的情况就少，就增加了并发处理，所以并发读写的效率还是很优秀的，问题在于索引查询后的根据主键的二次查找导致效率低</li>
</ul>
<h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><p>第一范式:每个属性都不可再分解<br>第二范式:每个属性都依赖与主键<br>第三范式:除了主键外，其他属性都没有依赖关系</p>
<h2 id="MYSQL-性能优化"><a href="#MYSQL-性能优化" class="headerlink" title="MYSQL 性能优化"></a>MYSQL 性能优化</h2><ul>
<li>选择合适的存储引擎,设计良好的数据库结构，选择合适的表字段数据类型,允许部分数据冗余（空间换时间）</li>
<li>适当的添加索引</li>
<li>优化 sql 语句，不同的语句，根据你选择的引擎、表中数据的分布情况、索引情况、数据库优化策略、查询中的锁策略等因素，最终查询的效率相差很大；优化要从整体去考虑，有时你优化一条语句后，其它查询反而效率被降低了，所以要取一个平衡点</li>
<li>Cache（缓存数据）<br>  查询：查询之前，要在Memcached或Redis中查找结果，如果找到，则返回它；如果未找到，则到数据库服务器上执行查询，并将结果返回给Memcached或Redis<br>  插入：先把数据插入数据库，在内存中受此影响的数据库将变成无效</li>
<li>读写分离</li>
<li>分布数据（分割数据）找规律分表,减少单表中的数据量提高查询速度</li>
</ul>
<h2 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h2><ul>
<li>一般的首页不应当有查询，对首页生成静态页面</li>
<li>不经常改动的页面,生成静态页面.</li>
</ul>
<h2 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h2><ul>
<li>垂直切分保证业务的独立性，防止不同业务争抢资源，毕竟业务是有优先级的</li>
<li>切分后也可对不同片数据进行不同优化。如按时间切分，超过一定时间数据不允许修改，就可以引入压缩了，数据传输及读取减少很多</li>
<li>数据是否存在明显的冷热（考虑旧数据归档）</li>
</ul>
<h2 id="MySQL数据库基本的三个优化法则"><a href="#MySQL数据库基本的三个优化法则" class="headerlink" title="MySQL数据库基本的三个优化法则"></a>MySQL数据库基本的三个优化法则</h2><ul>
<li>系统服务优化，把MySQL的key_buffer、cache_buffer、query_cache等参数提高<br>（sort_buffer_size,read_buffer_size,read_rnd_buffer_size,join_buffer_size ）</li>
<li>优化SQL语句，减少Ditinct、Group、Join等等语句的操作</li>
<li>给所有经常查询的字段增加适当的索引</li>
</ul>
<h2 id="mysql要注意的地方及技巧"><a href="#mysql要注意的地方及技巧" class="headerlink" title="mysql要注意的地方及技巧"></a>mysql要注意的地方及技巧</h2><ul>
<li>需要<code>utf8mb4</code>才能显示<code>emoji</code> </li>
<li>join查询不一定优于子查询</li>
<li>选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL</li>
<li>GUID替代AutoIncrement作为主键的唯一性保障</li>
<li>把update和访问频繁的数据cache在内存中</li>
<li>使用队列，控制消费速度</li>
<li>只存储英文字母时，该字段可不需要采用utf8, 可选择字符长度更小的字符集</li>
<li>使用mysql自带的query cache，对应用基本完全透明。但会受限于本机。而且只缓存查询结果，mc和redis可以缓存一些加工后的数据</li>
</ul>
<h2 id="不好操作"><a href="#不好操作" class="headerlink" title="不好操作"></a>不好操作</h2><ul>
<li>主主复制（主键值分配、数据冲突）</li>
<li>水平分表（如果将来一定会到这个规模，又可能用到，建议越早做越好）</li>
</ul>
<h2 id="关于主从复制、读写分离"><a href="#关于主从复制、读写分离" class="headerlink" title="关于主从复制、读写分离"></a>关于主从复制、读写分离</h2><ul>
<li>增加了数据的冗余备份，提高了可用性</li>
<li>扩展读</li>
<li>从库可配置myisam引擎及其他针对性设置，提升查询性能以及节约系统开销</li>
<li>主库向从库发送binlog是异步的，从库恢复数据也是异步的</li>
<li>当节点比较多时，使用多级缓存，减轻主的压力</li>
<li>读产生了延迟，牺牲了一致性</li>
</ul>
<h2 id="关于数据库外键及其他高级特性-触发器、存储过程等"><a href="#关于数据库外键及其他高级特性-触发器、存储过程等" class="headerlink" title="关于数据库外键及其他高级特性(触发器、存储过程等)"></a>关于数据库外键及其他高级特性(触发器、存储过程等)</h2><ul>
<li>增加数据库负担(外键作用：约束数据库的一致性)</li>
<li>用户量大，并发度高时数据库很容易成为性能瓶颈</li>
<li>数据库不容易水平伸缩，应用服务器能轻松地水平伸缩</li>
<li>将这些特性分离到程序中作为数据逻辑</li>
<li>不经常改的常数,可使用外键,来记录数据关系.而那些经常更改的,使用更高层的逻辑来记录数据关系.</li>
</ul>
<h2 id="mysql-vs-oracle"><a href="#mysql-vs-oracle" class="headerlink" title="mysql vs oracle"></a>mysql vs oracle</h2><ul>
<li>Oracle目前还是最先进的关系数据库，其传统使用方法：存储使用EMC阵列（容量大，数据安全），IBM服务器，即IOE组合，这三个组合很强大（高可用，高性能），但是也高价格</li>
<li>MySQL的优势:<ul>
<li>省去了巨额license费用</li>
<li>MySQL代码开源，可以根据业务特点定制和优化</li>
<li>将MySQL运行在普通PC上，硬件费用大大降低</li>
</ul>
</li>
</ul>
<h3 id="mysql中int、bigint、smallint-和-tinyint的区别与长度的含义"><a href="#mysql中int、bigint、smallint-和-tinyint的区别与长度的含义" class="headerlink" title="mysql中int、bigint、smallint 和 tinyint的区别与长度的含义"></a>mysql中int、bigint、smallint 和 tinyint的区别与长度的含义</h3><ul>
<li><p>bigint<br>从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。<br>P.S. bigint已经有长度了，在mysql建表中的length，只是用于显示的位数</p>
</li>
<li><p>int<br>从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。</p>
</li>
<li><p>smallint<br>从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据。存储大小为 2 个字节。</p>
</li>
<li><p>tinyint<br>从 0 到 255 的整型数据。存储大小为 1 字节。<br>int(M) 在 integer 数据类型中，M 表示最大显示宽度。在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。和数字位数也无关系 int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。<br>TinyINT(M) always has a range from -128..+127 signed or 0..255 unsigned. M is the display width.</p>
</li>
</ul>
<h3 id="Importance-of-varchar-length-in-MySQL-table"><a href="#Importance-of-varchar-length-in-MySQL-table" class="headerlink" title="Importance of varchar length in MySQL table"></a>Importance of varchar length in MySQL table</h3><p>There’s one possible performance impact: in MySQL, temporary tables and MEMORY tables store a VARCHAR column as a fixed-length column, padded out to its maximum length. If you design VARCHAR columns much larger than the greatest size you need, you will consume more memory than you have to. This affects cache efficiency, sorting speed, etc.</p>
<p>This is the var (variable) in varchar: you only store what you enter (and an extra 2 bytes to store length upto 65535)</p>
<p>To be clear: Storing a string 100 characters in a varchar(200) field will take 101 bytes. Storing a string of 100 characters in a varchar(256) field will take 102 bytes. This is why you see varchar(255) so frequently; 255 characters is the longest string you can store in MySQL’s varchar type with only one byte of overhead. Anything larger requires two bytes of overhead. </p>
<p>varchar(N) N is the number of characters, so varchar(255) charset utf8mb4 would actually use up to 1021 bytes</p>
<p>Specifically, when doing sorting, larger column do take up more space, so if that hurts performance, then you need to worry about it and make them smaller. But if you only ever select 1 row from that table, then you can just make them all 255 and it won’t matter.</p>
<p><a href="https://dba.stackexchange.com/questions/76469/mysql-varchar-length-and-performance" target="_blank" rel="external">看看这个</a></p>
<h2 id="选择合适的-MySQL-日期时间类型来存储你的时间"><a href="#选择合适的-MySQL-日期时间类型来存储你的时间" class="headerlink" title="选择合适的 MySQL 日期时间类型来存储你的时间"></a>选择合适的 MySQL 日期时间类型来存储你的时间</h2><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>timestamp（1970-2038）<br>datetime （1000-9999）<br>int 是从1970年开始累加的，但是 int 支持的范围是 1901-12-13 到 2038-01-19 03:14:07，如果需要更大的范围需要设置为 bigInt。但是这个时间不包含毫秒，如果需要毫秒，还需要定义为浮点数。<br>datetime 和 timestamp 原生自带6位的微秒。</p>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><p>timestamp 是自带时区转换的,可记录经常变化的更新/创建/发布/日志时间/购买时间/登录时间/注册时间等，并且是近来的时间，够用，时区自动处理，比如说做海外购或者业务可能拓展到海外<br>datetime 记录固定时间如服务器执行计划任务时间/健身锻炼计划时间等，在任何时区都是需要一个固定的时间要做某个事情。超出 timestamp 的时间，如果需要时区必须记得时区处理</p>
<h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>状态值：tinyint；<br>有限范围值：根据范围选择tinyint(不要用enum)，smallint，mediumint ,int, bigint, float, double；<br>从技术上尽可能将字段设置成NOT NULL，但如果业务上要求该字段可以为NULL，而且如果该字段不会被建立索引，则保持NULL，否则可以用’’(空字符串)代替；</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>mysql5.6.4支持innodb的全文搜索</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL存储引擎-MyISAM-和-InnoDB-的区别&quot;&gt;&lt;a href=&quot;#MySQL存储引擎-MyISAM-和-InnoDB-的区别&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎 MyISAM 和 InnoDB 的区别&quot;&gt;&lt;/a&gt;MySQL存储引擎 MyISAM 和 InnoDB 的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;MyISAM类型不支持事务处理等高级处理,而InnoDB类型支持.&lt;/li&gt;
&lt;li&gt;InnoDB不支持FULLTEXT类型的索引.&lt;/li&gt;
&lt;li&gt;InnoDB中不保存表的具体行数,但是MyISAM只要简单的读出保存好的行数即可.&lt;/li&gt;
&lt;li&gt;MyISAM支持表锁，只有读读之间是并发的，写写之间和读写之间（读和插入之间是可以并发的，去设置concurrent_insert参数，定期执行表优化操作，更新操作就没有办法了）是串行的，所以写起来慢；InnoDB支持行锁，这个一般指的是sql用到索引的时候，行锁是加在索引上的，不是加在数据记录上的，如果sql没有用到索引，仍然会锁定表，普通的select是不需要锁的&lt;/li&gt;
&lt;li&gt;MyISAM索引btree上的节点是一个指向数据物理位置的指针，所以查找起来很快；nnodb索引节点存的则是数据的主键，所以需要根据主键二次查找&lt;/li&gt;
&lt;li&gt;因为在使用索引的时候用的是行锁，锁的粒度小，竞争相同锁的情况就少，就增加了并发处理，所以并发读写的效率还是很优秀的，问题在于索引查询后的根据主键的二次查找导致效率低&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据库设计范式&quot;&gt;&lt;a href=&quot;#数据库设计范式&quot; class=&quot;headerlink&quot; title=&quot;数据库设计范式&quot;&gt;&lt;/a&gt;数据库设计范式&lt;/h2&gt;&lt;p&gt;第一范式:每个属性都不可再分解&lt;br&gt;第二范式:每个属性都依赖与主键&lt;br&gt;第三范式:除了主键外，其他属性都没有依赖关系&lt;/p&gt;
&lt;h2 id=&quot;MYSQL-性能优化&quot;&gt;&lt;a href=&quot;#MYSQL-性能优化&quot; class=&quot;headerlink&quot; title=&quot;MYSQL 性能优化&quot;&gt;&lt;/a&gt;MYSQL 性能优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;选择合适的存储引擎,设计良好的数据库结构，选择合适的表字段数据类型,允许部分数据冗余（空间换时间）&lt;/li&gt;
&lt;li&gt;适当的添加索引&lt;/li&gt;
&lt;li&gt;优化 sql 语句，不同的语句，根据你选择的引擎、表中数据的分布情况、索引情况、数据库优化策略、查询中的锁策略等因素，最终查询的效率相差很大；优化要从整体去考虑，有时你优化一条语句后，其它查询反而效率被降低了，所以要取一个平衡点&lt;/li&gt;
&lt;li&gt;Cache（缓存数据）&lt;br&gt;  查询：查询之前，要在Memcached或Redis中查找结果，如果找到，则返回它；如果未找到，则到数据库服务器上执行查询，并将结果返回给Memcached或Redis&lt;br&gt;  插入：先把数据插入数据库，在内存中受此影响的数据库将变成无效&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;分布数据（分割数据）找规律分表,减少单表中的数据量提高查询速度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;关于缓存&quot;&gt;&lt;a href=&quot;#关于缓存&quot; class=&quot;headerlink&quot; title=&quot;关于缓存&quot;&gt;&lt;/a&gt;关于缓存&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高并发</title>
    <link href="https://entimm.com/2016/09/05/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>https://entimm.com/2016/09/05/高并发/</id>
    <published>2016-09-05T15:57:49.000Z</published>
    <updated>2016-09-05T15:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>用同步队列，就可以实现。库存比如是1000，那就存1000个随机数到队列中，拿到随机数的人去换取真实的商品。这样数据库的压力都小。最多更新1000次。队列可以系统加载时创建，也可以做为持久化保存在文件中。</p>
<h2 id="关于库存和秒杀的解决方案"><a href="#关于库存和秒杀的解决方案" class="headerlink" title="关于库存和秒杀的解决方案"></a>关于库存和秒杀的解决方案</h2><ol>
<li>用额外的单进程处理一个队列，下单请求放到队列里，一个个处理，就不会有并发的问题了，但是要额外的后台进程以及延迟问题，不予考虑。</li>
<li>根据update结果来判断，我们可以加一个判断条件update … where 库存&gt;0，如果返回false，则说明库存不足，并回滚事务。</li>
<li>借助文件排他锁，在处理下单请求的时候，用flock锁定一个文件，如果锁定失败说明有其他订单正在处理，此时要么等待要么直接提示用户”服务器繁忙”</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//阻塞(等待)模式</span></div><div class="line">$fp = fopen(<span class="string">"lock.txt"</span>, <span class="string">"w+"</span>);</div><div class="line"><span class="keyword">if</span>(flock($fp,LOCK_EX))</div><div class="line">&#123;</div><div class="line">    <span class="comment">//..处理订单</span></div><div class="line">    flock($fp,LOCK_UN);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fclose($fp);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非阻塞模式</span></div><div class="line">$fp = fopen(<span class="string">"lock.txt"</span>, <span class="string">"w+"</span>);</div><div class="line"><span class="keyword">if</span>(flock($fp,LOCK_EX | LOCK_NB))</div><div class="line">&#123;</div><div class="line">    <span class="comment">//..处理订单</span></div><div class="line">    flock($fp,LOCK_UN);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"系统繁忙，请稍后再试"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fclose($fp);</div><div class="line"></div><div class="line"><span class="comment">//采用哪种方式，看并发数量吧。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用同步队列，就可以实现。库存比如是1000，那就存1000个随机数到队列中，拿到随机数的人去换取真实的商品。这样数据库的压力都小。最多更新1000次。队列可以系统加载时创建，也可以做为持久化保存在文件中。&lt;/p&gt;
&lt;h2 id=&quot;关于库存和秒杀的解决方案&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker 技巧</title>
    <link href="https://entimm.com/2016/09/05/docker%E6%8A%80%E5%B7%A7/"/>
    <id>https://entimm.com/2016/09/05/docker技巧/</id>
    <published>2016-09-05T15:55:19.000Z</published>
    <updated>2016-09-05T15:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除-none-tag-镜像"><a href="#删除-none-tag-镜像" class="headerlink" title="删除 none tag 镜像"></a>删除 none tag 镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &apos;&#123;print $3&#125;&apos;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi $(docker images -q --filter &quot;dangling=true&quot;)</div></pre></td></tr></table></figure>
<h2 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images -q | xargs docker rmi</div></pre></td></tr></table></figure>
<h2 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -q -a | xargs docker rm</div></pre></td></tr></table></figure>
<h2 id="删除所有停止运行的容器"><a href="#删除所有停止运行的容器" class="headerlink" title="删除所有停止运行的容器"></a>删除所有停止运行的容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $( docker ps -q -f status=exited)</div></pre></td></tr></table></figure>
<h2 id="删除所有-dangling-unused-的镜像"><a href="#删除所有-dangling-unused-的镜像" class="headerlink" title="删除所有 dangling (unused) 的镜像"></a>删除所有 dangling (unused) 的镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi $( docker images -q -f dangling=true)</div></pre></td></tr></table></figure>
<h2 id="xargs-with-–no-run-if-empty-is-even-better-as-it-does-cleanly-handle-the-case-when-there-is-nothing-to-be-removed"><a href="#xargs-with-–no-run-if-empty-is-even-better-as-it-does-cleanly-handle-the-case-when-there-is-nothing-to-be-removed" class="headerlink" title="xargs with –no-run-if-empty is even better as it does cleanly handle the case when there is nothing to be removed."></a>xargs with –no-run-if-empty is even better as it does cleanly handle the case when there is nothing to be removed.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Delete all stopped containers</div><div class="line">docker ps -q -f status=exited | xargs --no-run-if-empty docker rm</div><div class="line"># Delete all dangling (unused) images</div><div class="line">docker images -q -f dangling=true | xargs --no-run-if-empty docker rmi</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;删除-none-tag-镜像&quot;&gt;&lt;a href=&quot;#删除-none-tag-镜像&quot; class=&quot;headerlink&quot; title=&quot;删除 none tag 镜像&quot;&gt;&lt;/a&gt;删除 none tag 镜像&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker rmi $(docker images | grep &amp;quot;^&amp;lt;none&amp;gt;&amp;quot; | awk &amp;apos;&amp;#123;print $3&amp;#125;&amp;apos;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker rmi $(docker images -q --filter &amp;quot;dangling=true&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;删除所有镜像&quot;&gt;&lt;a href=&quot;#删除所有镜像&quot; class=&quot;headerlink&quot; title=&quot;删除所有镜像&quot;&gt;&lt;/a&gt;删除所有镜像&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker images -q | xargs docker rmi&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;删除所有容器&quot;&gt;&lt;a href=&quot;#删除所有容器&quot; class=&quot;headerlink&quot; title=&quot;删除所有容器&quot;&gt;&lt;/a&gt;删除所有容器&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker ps -q -a | xargs docker rm&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快捷键</title>
    <link href="https://entimm.com/2016/09/04/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://entimm.com/2016/09/04/快捷键/</id>
    <published>2016-09-04T05:15:30.000Z</published>
    <updated>2016-09-04T05:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><p>CMD-Shift-3<br>    全屏截图</p>
<p>CMD-Shift-4<br>    区域截图：选区<br>    ⇧Shift － 重新定义截图区域的纵向高度或横向长度，不能同时实现。<br>    ⌥Option － 重新定义截图区域的尺寸，可以同时实现纵向和横向的改变，但只能围绕中心区域展开。<br>    ⌴空格键 － 按住并拖动鼠标，可以移动截图选框位置。<br>    Escape(Esc)键 － 退出截图模式。</p>
<p>CMD-Shift-4 + 空格键<br>    区域截图：窗口</p>
<p>screencapture -T ＋等待时间（秒）＋保存的截图名称及格式<br>    抓图</p>
<h3 id="phpStorm"><a href="#phpStorm" class="headerlink" title="phpStorm"></a>phpStorm</h3><ul>
<li>command + r 查找替换</li>
<li>command + e 打开最近的文件</li>
<li>command + shift + o 快速查询文件</li>
<li>command + shift + f 关键字查找,更强大的查询器(机器不好的，最好还是先确定一下目录)</li>
<li>command + shift + r 高级替换</li>
<li>command + alt + b 找到当前类的所有子类</li>
<li>alt + shift + c 查找最近修改的文件</li>
<li>alt + f7 直接查询选中的字符</li>
<li>ctrl + f7 文件中查询选中字符</li>
<li>command + shift + +,- 展开或缩起</li>
<li><p>command + . 折叠或展开选中的代码</p>
</li>
<li><p>alt + 回车 导入包，自动修正</p>
</li>
<li>command + n 快事为每个成员属性生成 getter 及 setter 方法</li>
<li>ctrl + i 快速生成插入魔术方法</li>
<li>ctrol + o 复写父类方法</li>
<li>command + alt + l 对当前文件进行格式化排版</li>
<li>command + d 复制当剪行</li>
<li>command + / // 注释</li>
<li>command + shift + / // 注释</li>
<li>command + k 提交代码</li>
<li>command + shif + k 提交远程分支</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h3&gt;&lt;p&gt;CMD-Shift-3&lt;br&gt;    全屏截图&lt;/p&gt;
&lt;p&gt;CMD-Shift-4&lt;br&gt;    区域截图：选区&lt;br&gt;    ⇧Shift － 重新定义截图区域的纵向高度或横向长度，不能同时实现。&lt;br&gt;    ⌥Option － 重新定义截图区域的尺寸，可以同时实现纵向和横向的改变，但只能围绕中心区域展开。&lt;br&gt;    ⌴空格键 － 按住并拖动鼠标，可以移动截图选框位置。&lt;br&gt;    Escape(Esc)键 － 退出截图模式。&lt;/p&gt;
&lt;p&gt;CMD-Shift-4 + 空格键&lt;br&gt;    区域截图：窗口&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用 CURL 进行数据抓取总结</title>
    <link href="https://entimm.com/2016/08/30/PHP%20cURL%20%E5%BA%94%E7%94%A8/"/>
    <id>https://entimm.com/2016/08/30/PHP cURL 应用/</id>
    <published>2016-08-30T06:08:16.000Z</published>
    <updated>2016-08-30T06:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>CURLOPT_POST 的设置可以指定当前提交是否为POST方式</p>
<p>CURLOPT_POSTFIELDS则用于设定提交的参数，可以是参数串，也可以是参数数组</p>
<h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>对于一些程序，它可能判断来源网址，如果发现referer不是自己的网站，则拒绝访问，这时候，我们就需要添加<code>CURLOPT_REFERER</code>参数</p>
<h2 id="cookie支持"><a href="#cookie支持" class="headerlink" title="cookie支持"></a>cookie支持</h2><p>对于模拟登录的应用，单单提交参数和模拟来路并不能解决问题，这时候我们就需要保存或者提交相应的Cookie参数</p>
<p>CURLOPT_COOKIE： 直接使用字符串方式提交cookie参数 </p>
<p>CURLOPT_COOKIEFILE： 使用文件方式提交cookie参数 </p>
<p>CURLOPT_COOKIEJAR： 保存提交后反馈的cookie数据</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">header(<span class="string">"content-Type: text/html; charset=UTF-8"</span>);</div><div class="line">$cookie_file = tempnam(<span class="string">'./temp'</span>, <span class="string">'cookie'</span>);</div><div class="line">$login_url=<span class="string">"http://somesite.com/login.php"</span>;</div><div class="line">$post_fields=<span class="string">"cktime=36000&amp;step=2&amp;pwuser=username&amp;pwpwd=password"</span>;</div><div class="line"><span class="comment">//提交登录表单请求</span></div><div class="line">$ch=curl_init($login_url);</div><div class="line">curl_setopt($ch,CURLOPT_HEADER,<span class="number">0</span>);</div><div class="line">curl_setopt($ch,CURLOPT_RETURNTRANSFER,<span class="number">1</span>);</div><div class="line">curl_setopt($ch,CURLOPT_POST,<span class="number">1</span>);</div><div class="line">curl_setopt($ch,CURLOPT_POSTFIELDS,$post_fields);</div><div class="line">curl_setopt($ch,CURLOPT_COOKIEJAR,$cookie_file); <span class="comment">//存储提交后得到的cookie数据</span></div><div class="line">curl_exec($ch);</div><div class="line">curl_close($ch);</div><div class="line"><span class="comment">//登录成功后，获取bbs首页数据</span></div><div class="line">$url=<span class="string">"http://somesite.com/index.php"</span>;</div><div class="line">$ch=curl_init($url);</div><div class="line">curl_setopt($ch,CURLOPT_HEADER,<span class="number">0</span>);</div><div class="line">curl_setopt($ch,CURLOPT_RETURNTRANSFER,<span class="number">1</span>);</div><div class="line">curl_setopt($ch,CURLOPT_COOKIEFILE,$cookie_file); <span class="comment">//使用提交后得到的cookie数据做参数</span></div><div class="line">$contents=curl_exec($ch);</div><div class="line">curl_close($ch);</div><div class="line"><span class="comment">//转码显示</span></div><div class="line"><span class="keyword">echo</span> iconv(<span class="string">'gbk'</span>, <span class="string">'UTF-8'</span>, $contents);</div></pre></td></tr></table></figure>
<h2 id="压缩网页gzip"><a href="#压缩网页gzip" class="headerlink" title="压缩网页gzip"></a>压缩网页gzip</h2><p>有些没有接触过压缩页面的朋友估计会在这里被坑死，因为他们会发现采集回来的内容是乱码，并且无论使用iconv还是强大的mb_convert_encoding都无法还原数据，然后又没有概念，各种抓狂却找不到方法</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$url = <span class="string">'http://news.sohu.com/'</span>;</div><div class="line">$ch = curl_init($url);</div><div class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>); <span class="comment">//返回数据不直接输出</span></div><div class="line">curl_setopt($ch, CURLOPT_ENCODING, <span class="string">"gzip"</span>); <span class="comment">//指定gzip压缩</span></div><div class="line">$content = curl_exec($ch); <span class="comment">//执行并存储结果</span></div><div class="line">curl_close($ch);</div><div class="line"><span class="keyword">echo</span> $content;</div></pre></td></tr></table></figure>
<p>支持的编码有”identity”，”deflate”和”gzip”</p>
<p>如果为空字符串””，请求头会发送所有支持的编码类型。后面一句表明，使用curl_setopt($ch, CURLOPT_ENCODING, “”);也是可以的，但是不能不加这个参数。</p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>var_dump(curl_error($ch));的方法打印错误提示，然后根据错误提示查找相应的解决方案。比如SSL错误常见提示：SSL certificate problem: unable to get local issuer certificate，这时候，我们就需要利用参数：CURLOPT_SSL_VERIFYPEER 和 CURLOPT_SSL_VERIFYHOST 来禁用SSL证书的验证，我尝试过只使用CURLOPT_SSL_VERIFYPEER参数禁用失败，所以大家最好同时使用两个参数。 </p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>国内存在万恶的墙，所以，假如我们需要获取某些被墙数据时，就需要用到国外代理服务器；<br>又或者我们需要采集大量数据时，需要不断切换IP，也会用到代理。 </p>
<p>使用代理在PHP cURL里面有几个相对应的参数：CURLOPT_PROXY、CURLOPT_PROXYPORT 和 CURLOPT_PROXYUSERPWD，还有另外几个，这里不列举。 </p>
<p>CURLOPT_PROXY 指定代理IP参数 </p>
<p>CURLOPT_PROXYPORT 指定代理端口参数 </p>
<p>CURLOPT_PROXYUSERPWD 指定需要验证的代理的账号密码，”[username]:[password]”格式的字符串</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>curl_multi</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>CURLOPT_FOLLOWLOCATION</p>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><blockquote>
<p>全部数据使用HTTP协议中的”POST”操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。<br>这个参数可以通过urlencoded后的字符串类似’para1=val1&amp;para2=val2&amp;…’或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content-Type头将会被设置成multipart/form-data。</p>
</blockquote>
<p>关于CURLOPT_POSTFIELDS的赋值，另外补充一句描述：</p>
<p>传递一个URL-encoded字符串时，数据会被编码成 application/x-www-form-urlencoded<br>传递一个数组到CURLOPT_POSTFIELDS，cURL会把数据编码成 multipart/form-data<br>即：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, <span class="string">'param1=val1&amp;param2=val2&amp;...'</span>);</div><div class="line"><span class="comment">// 相当于</span></div><div class="line"><span class="comment">// &lt;form method="post" action="upload.php"&gt;</span></div><div class="line"></div><div class="line">curl_setopt($ch, CURLOPT_POSTFIELDS, <span class="keyword">array</span>(<span class="string">'param1'</span> =&gt; <span class="string">'val1'</span>, <span class="string">'param2'</span> =&gt; <span class="string">'val2'</span>, ...));</div><div class="line"><span class="comment">// 相当于</span></div><div class="line"><span class="comment">// &lt;form method="post" action="upload.php" enctype="multipart/form-data"&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POST&quot;&gt;&lt;a href=&quot;#POST&quot; class=&quot;headerlink&quot; title=&quot;POST&quot;&gt;&lt;/a&gt;POST&lt;/h2&gt;&lt;p&gt;CURLOPT_POST 的设置可以指定当前提交是否为POST方式&lt;/p&gt;
&lt;p&gt;CURLOPT_POSTFIELDS则用于设定提交的参数，可以是参数串，也可以是参数数组&lt;/p&gt;
&lt;h2 id=&quot;Referer&quot;&gt;&lt;a href=&quot;#Referer&quot; class=&quot;headerlink&quot; title=&quot;Referer&quot;&gt;&lt;/a&gt;Referer&lt;/h2&gt;&lt;p&gt;对于一些程序，它可能判断来源网址，如果发现referer不是自己的网站，则拒绝访问，这时候，我们就需要添加&lt;code&gt;CURLOPT_REFERER&lt;/code&gt;参数&lt;/p&gt;
&lt;h2 id=&quot;cookie支持&quot;&gt;&lt;a href=&quot;#cookie支持&quot; class=&quot;headerlink&quot; title=&quot;cookie支持&quot;&gt;&lt;/a&gt;cookie支持&lt;/h2&gt;&lt;p&gt;对于模拟登录的应用，单单提交参数和模拟来路并不能解决问题，这时候我们就需要保存或者提交相应的Cookie参数&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>laravel</title>
    <link href="https://entimm.com/2016/08/30/laravel/"/>
    <id>https://entimm.com/2016/08/30/laravel/</id>
    <published>2016-08-30T05:19:11.000Z</published>
    <updated>2016-08-30T05:19:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于laravel的性能"><a href="#关于laravel的性能" class="headerlink" title="关于laravel的性能"></a>关于laravel的性能</h3><p>如果你在一个 Start Up 的话, 要求快速上线, 快速验证自己的想法, 高级语言之所以高级, 就是因为开发便捷性, 这个时候开发速度是最重要的, 你产品做了三个月, 甚至半年的, 但是, 你的对手可能用了几天时间一个原型就出来了, 几个星期就验证了 idea, 然后一边找风头, 一个月的时间内, 几百万美元的投资协议就签下, 随着后面的产品快速迭代, 迅速推出新的功能, 受到用户的喜爱, 几个月后, 用户量上好几百万, 然后, A 轮上千万美元的融资也下来了, 这个时候有负载问题, 有并发问题, 但是, 这个时候, 有了那么多钱, 并发真的需要那么担心吗? 年薪 50w ~ 100w, 请几个专家过来, 编译器都能给你重写.</p>
<p>使用 ROR 的 Twitter, 使用 PHP 的 Facebook, 都是非常好的证明: “性能不是一个 Start Up 应该太担心的问题, 产品, 用户体验!</p>
<p>至于这个, 例如对于 Web 前端页面, 加个 CDN, 服务器端加个 Cache, 优化下 SQL, 负载均衡, PHP 加个 OpCache这些得到的程序总体性能随随便便就是编译器优化的无数倍.</p>
<p>生产环境下的 Laravel 调优: 减少 providers 的加载</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>添加自定义的服务<br>1、在App\Providers下建立自己的服务类与服务提供者<br>2、在config\app下的providers数组中注册该服务提供者<br>3、使用$this-&gt;app[‘ServiceName’]来取得该服务类的示例，此时可以通过示例来调用服务类的方法等</p>
<p>为服务创建facade<br>1、在App下建立Facades文件夹统一放置facades<br>2、在config\app下的aliases数组中为该facade注册别名<br>3、通过facade调用相应服务类的方法，例如My::sayHello()</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于laravel的性能&quot;&gt;&lt;a href=&quot;#关于laravel的性能&quot; class=&quot;headerlink&quot; title=&quot;关于laravel的性能&quot;&gt;&lt;/a&gt;关于laravel的性能&lt;/h3&gt;&lt;p&gt;如果你在一个 Start Up 的话, 要求快速上线, 快速验证自己的想法, 高级语言之所以高级, 就是因为开发便捷性, 这个时候开发速度是最重要的, 你产品做了三个月, 甚至半年的, 但是, 你的对手可能用了几天时间一个原型就出来了, 几个星期就验证了 idea, 然后一边找风头, 一个月的时间内, 几百万美元的投资协议就签下, 随着后面的产品快速迭代, 迅速推出新的功能, 受到用户的喜爱, 几个月后, 用户量上好几百万, 然后, A 轮上千万美元的融资也下来了, 这个时候有负载问题, 有并发问题, 但是, 这个时候, 有了那么多钱, 并发真的需要那么担心吗? 年薪 50w ~ 100w, 请几个专家过来, 编译器都能给你重写.&lt;/p&gt;
&lt;p&gt;使用 ROR 的 Twitter, 使用 PHP 的 Facebook, 都是非常好的证明: “性能不是一个 Start Up 应该太担心的问题, 产品, 用户体验!&lt;/p&gt;
&lt;p&gt;至于这个, 例如对于 Web 前端页面, 加个 CDN, 服务器端加个 Cache, 优化下 SQL, 负载均衡, PHP 加个 OpCache这些得到的程序总体性能随随便便就是编译器优化的无数倍.&lt;/p&gt;
&lt;p&gt;生产环境下的 Laravel 调优: 减少 providers 的加载&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript</title>
    <link href="https://entimm.com/2016/08/30/javascript/"/>
    <id>https://entimm.com/2016/08/30/javascript/</id>
    <published>2016-08-30T05:17:51.000Z</published>
    <updated>2016-08-30T05:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="set-checked"><a href="#set-checked" class="headerlink" title="set checked"></a>set checked</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"checkbox"</span>).checked = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">//  Uncheck</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"checkbox"</span>).checked = <span class="literal">false</span>;</div><div class="line">jQuery (<span class="number">1.6</span>+):</div><div class="line"></div><div class="line"><span class="comment">// Check</span></div><div class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//  Uncheck</span></div><div class="line">$(<span class="string">"#checkbox"</span>).prop(<span class="string">"checked"</span>, <span class="literal">false</span>);</div><div class="line">jQuery (<span class="number">1.5</span>-):</div><div class="line"></div><div class="line"><span class="comment">// Check</span></div><div class="line">$(<span class="string">"#checkbox"</span>).attr(<span class="string">"checked"</span>, <span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//  Uncheck</span></div><div class="line">$(<span class="string">"#checkbox"</span>).attr(<span class="string">"checked"</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//Check</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'checkbox'</span>).setAttribute(<span class="string">'checked'</span>, <span class="string">'checked'</span>);</div><div class="line"></div><div class="line"><span class="comment">//UnCheck</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'checkbox'</span>).removeAttribute(<span class="string">'checked'</span>);</div></pre></td></tr></table></figure>
<h3 id="get-checked"><a href="#get-checked" class="headerlink" title="get checked"></a>get checked</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// traditional attr</span></div><div class="line">$(<span class="string">'#checkMeOut'</span>).attr(<span class="string">'checked'</span>); <span class="comment">// "checked"</span></div><div class="line"><span class="comment">// new property method</span></div><div class="line">$(<span class="string">'#checkMeOut'</span>).prop(<span class="string">'checked'</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line">$(<span class="string">"#txtAge"</span>).get(<span class="number">0</span>).checked</div><div class="line">$(<span class="string">"#txtAge"</span>).is(<span class="string">":checked"</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;set-checked&quot;&gt;&lt;a href=&quot;#set-checked&quot; class=&quot;headerlink&quot; title=&quot;set checked&quot;&gt;&lt;/a&gt;set checked&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
